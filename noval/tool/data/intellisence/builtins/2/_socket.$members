(dp0
S'doc'
p1
S'Implementation module for socket operations.\n\nSee the socket module for documentation.'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'AF_APPLETALK'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'AF_ASH'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'AF_ATMPVC'
p13
sa(dp14
g3
I01
sg7
I5
sg8
S'AF_ATMSVC'
p15
sa(dp16
g3
I01
sg7
I5
sg8
S'AF_AX25'
p17
sa(dp18
g3
I01
sg7
I5
sg8
S'AF_BLUETOOTH'
p19
sa(dp20
g3
I01
sg7
I5
sg8
S'AF_BRIDGE'
p21
sa(dp22
g3
I01
sg7
I5
sg8
S'AF_DECnet'
p23
sa(dp24
g3
I01
sg7
I5
sg8
S'AF_ECONET'
p25
sa(dp26
g3
I01
sg7
I5
sg8
S'AF_INET'
p27
sa(dp28
g3
I01
sg7
I5
sg8
S'AF_INET6'
p29
sa(dp30
g3
I01
sg7
I5
sg8
S'AF_IPX'
p31
sa(dp32
g3
I01
sg7
I5
sg8
S'AF_IRDA'
p33
sa(dp34
g3
I01
sg7
I5
sg8
S'AF_KEY'
p35
sa(dp36
g3
I01
sg7
I5
sg8
S'AF_LLC'
p37
sa(dp38
g3
I01
sg7
I5
sg8
S'AF_NETBEUI'
p39
sa(dp40
g3
I01
sg7
I5
sg8
S'AF_NETLINK'
p41
sa(dp42
g3
I01
sg7
I5
sg8
S'AF_NETROM'
p43
sa(dp44
g3
I01
sg7
I5
sg8
S'AF_PACKET'
p45
sa(dp46
g3
I01
sg7
I5
sg8
S'AF_PPPOX'
p47
sa(dp48
g3
I01
sg7
I5
sg8
S'AF_ROSE'
p49
sa(dp50
g3
I01
sg7
I5
sg8
S'AF_ROUTE'
p51
sa(dp52
g3
I01
sg7
I5
sg8
S'AF_SECURITY'
p53
sa(dp54
g3
I01
sg7
I5
sg8
S'AF_SNA'
p55
sa(dp56
g3
I01
sg7
I5
sg8
S'AF_TIPC'
p57
sa(dp58
g3
I01
sg7
I5
sg8
S'AF_UNIX'
p59
sa(dp60
g3
I01
sg7
I5
sg8
S'AF_UNSPEC'
p61
sa(dp62
g3
I01
sg7
I5
sg8
S'AF_WANPIPE'
p63
sa(dp64
g3
I01
sg7
I5
sg8
S'AF_X25'
p65
sa(dp66
g3
I01
sg7
I5
sg8
S'AI_ADDRCONFIG'
p67
sa(dp68
g3
I01
sg7
I5
sg8
S'AI_ALL'
p69
sa(dp70
g3
I01
sg7
I5
sg8
S'AI_CANONNAME'
p71
sa(dp72
g3
I01
sg7
I5
sg8
S'AI_NUMERICHOST'
p73
sa(dp74
g3
I01
sg7
I5
sg8
S'AI_NUMERICSERV'
p75
sa(dp76
g3
I01
sg7
I5
sg8
S'AI_PASSIVE'
p77
sa(dp78
g3
I01
sg7
I5
sg8
S'AI_V4MAPPED'
p79
sa(dp80
g3
I01
sg7
I5
sg8
S'BDADDR_ANY'
p81
sa(dp82
g3
I01
sg7
I5
sg8
S'BDADDR_LOCAL'
p83
sa(dp84
g3
I01
sg7
I5
sg8
S'BTPROTO_HCI'
p85
sa(dp86
g3
I01
sg7
I5
sg8
S'BTPROTO_L2CAP'
p87
sa(dp88
g3
I01
sg7
I5
sg8
S'BTPROTO_RFCOMM'
p89
sa(dp90
g3
I01
sg7
I5
sg8
S'BTPROTO_SCO'
p91
sa(dp92
g3
I01
sg7
I5
sg8
S'CAPI'
p93
sa(dp94
g3
I01
sg7
I5
sg8
S'EAI_ADDRFAMILY'
p95
sa(dp96
g3
I01
sg7
I5
sg8
S'EAI_AGAIN'
p97
sa(dp98
g3
I01
sg7
I5
sg8
S'EAI_BADFLAGS'
p99
sa(dp100
g3
I01
sg7
I5
sg8
S'EAI_FAIL'
p101
sa(dp102
g3
I01
sg7
I5
sg8
S'EAI_FAMILY'
p103
sa(dp104
g3
I01
sg7
I5
sg8
S'EAI_MEMORY'
p105
sa(dp106
g3
I01
sg7
I5
sg8
S'EAI_NODATA'
p107
sa(dp108
g3
I01
sg7
I5
sg8
S'EAI_NONAME'
p109
sa(dp110
g3
I01
sg7
I5
sg8
S'EAI_OVERFLOW'
p111
sa(dp112
g3
I01
sg7
I5
sg8
S'EAI_SERVICE'
p113
sa(dp114
g3
I01
sg7
I5
sg8
S'EAI_SOCKTYPE'
p115
sa(dp116
g3
I01
sg7
I5
sg8
S'EAI_SYSTEM'
p117
sa(dp118
g3
I01
sg7
I5
sg8
S'HCI_DATA_DIR'
p119
sa(dp120
g3
I01
sg7
I5
sg8
S'HCI_FILTER'
p121
sa(dp122
g3
I01
sg7
I5
sg8
S'HCI_TIME_STAMP'
p123
sa(dp124
g3
I01
sg7
I5
sg8
S'INADDR_ALLHOSTS_GROUP'
p125
sa(dp126
g3
I01
sg7
I5
sg8
S'INADDR_ANY'
p127
sa(dp128
g3
I01
sg7
I5
sg8
S'INADDR_BROADCAST'
p129
sa(dp130
g3
I01
sg7
I5
sg8
S'INADDR_LOOPBACK'
p131
sa(dp132
g3
I01
sg7
I5
sg8
S'INADDR_MAX_LOCAL_GROUP'
p133
sa(dp134
g3
I01
sg7
I5
sg8
S'INADDR_NONE'
p135
sa(dp136
g3
I01
sg7
I5
sg8
S'INADDR_UNSPEC_GROUP'
p137
sa(dp138
g3
I01
sg7
I5
sg8
S'IPPORT_RESERVED'
p139
sa(dp140
g3
I01
sg7
I5
sg8
S'IPPORT_USERRESERVED'
p141
sa(dp142
g3
I01
sg7
I5
sg8
S'IPPROTO_AH'
p143
sa(dp144
g3
I01
sg7
I5
sg8
S'IPPROTO_DSTOPTS'
p145
sa(dp146
g3
I01
sg7
I5
sg8
S'IPPROTO_EGP'
p147
sa(dp148
g3
I01
sg7
I5
sg8
S'IPPROTO_ESP'
p149
sa(dp150
g3
I01
sg7
I5
sg8
S'IPPROTO_FRAGMENT'
p151
sa(dp152
g3
I01
sg7
I5
sg8
S'IPPROTO_GRE'
p153
sa(dp154
g3
I01
sg7
I5
sg8
S'IPPROTO_HOPOPTS'
p155
sa(dp156
g3
I01
sg7
I5
sg8
S'IPPROTO_ICMP'
p157
sa(dp158
g3
I01
sg7
I5
sg8
S'IPPROTO_ICMPV6'
p159
sa(dp160
g3
I01
sg7
I5
sg8
S'IPPROTO_IDP'
p161
sa(dp162
g3
I01
sg7
I5
sg8
S'IPPROTO_IGMP'
p163
sa(dp164
g3
I01
sg7
I5
sg8
S'IPPROTO_IP'
p165
sa(dp166
g3
I01
sg7
I5
sg8
S'IPPROTO_IPIP'
p167
sa(dp168
g3
I01
sg7
I5
sg8
S'IPPROTO_IPV6'
p169
sa(dp170
g3
I01
sg7
I5
sg8
S'IPPROTO_NONE'
p171
sa(dp172
g3
I01
sg7
I5
sg8
S'IPPROTO_PIM'
p173
sa(dp174
g3
I01
sg7
I5
sg8
S'IPPROTO_PUP'
p175
sa(dp176
g3
I01
sg7
I5
sg8
S'IPPROTO_RAW'
p177
sa(dp178
g3
I01
sg7
I5
sg8
S'IPPROTO_ROUTING'
p179
sa(dp180
g3
I01
sg7
I5
sg8
S'IPPROTO_RSVP'
p181
sa(dp182
g3
I01
sg7
I5
sg8
S'IPPROTO_TCP'
p183
sa(dp184
g3
I01
sg7
I5
sg8
S'IPPROTO_TP'
p185
sa(dp186
g3
I01
sg7
I5
sg8
S'IPPROTO_UDP'
p187
sa(dp188
g3
I01
sg7
I5
sg8
S'IPV6_CHECKSUM'
p189
sa(dp190
g3
I01
sg7
I5
sg8
S'IPV6_DONTFRAG'
p191
sa(dp192
g3
I01
sg7
I5
sg8
S'IPV6_DSTOPTS'
p193
sa(dp194
g3
I01
sg7
I5
sg8
S'IPV6_HOPLIMIT'
p195
sa(dp196
g3
I01
sg7
I5
sg8
S'IPV6_HOPOPTS'
p197
sa(dp198
g3
I01
sg7
I5
sg8
S'IPV6_JOIN_GROUP'
p199
sa(dp200
g3
I01
sg7
I5
sg8
S'IPV6_LEAVE_GROUP'
p201
sa(dp202
g3
I01
sg7
I5
sg8
S'IPV6_MULTICAST_HOPS'
p203
sa(dp204
g3
I01
sg7
I5
sg8
S'IPV6_MULTICAST_IF'
p205
sa(dp206
g3
I01
sg7
I5
sg8
S'IPV6_MULTICAST_LOOP'
p207
sa(dp208
g3
I01
sg7
I5
sg8
S'IPV6_NEXTHOP'
p209
sa(dp210
g3
I01
sg7
I5
sg8
S'IPV6_PATHMTU'
p211
sa(dp212
g3
I01
sg7
I5
sg8
S'IPV6_PKTINFO'
p213
sa(dp214
g3
I01
sg7
I5
sg8
S'IPV6_RECVDSTOPTS'
p215
sa(dp216
g3
I01
sg7
I5
sg8
S'IPV6_RECVHOPLIMIT'
p217
sa(dp218
g3
I01
sg7
I5
sg8
S'IPV6_RECVHOPOPTS'
p219
sa(dp220
g3
I01
sg7
I5
sg8
S'IPV6_RECVPATHMTU'
p221
sa(dp222
g3
I01
sg7
I5
sg8
S'IPV6_RECVPKTINFO'
p223
sa(dp224
g3
I01
sg7
I5
sg8
S'IPV6_RECVRTHDR'
p225
sa(dp226
g3
I01
sg7
I5
sg8
S'IPV6_RECVTCLASS'
p227
sa(dp228
g3
I01
sg7
I5
sg8
S'IPV6_RTHDR'
p229
sa(dp230
g3
I01
sg7
I5
sg8
S'IPV6_RTHDRDSTOPTS'
p231
sa(dp232
g3
I01
sg7
I5
sg8
S'IPV6_RTHDR_TYPE_0'
p233
sa(dp234
g3
I01
sg7
I5
sg8
S'IPV6_TCLASS'
p235
sa(dp236
g3
I01
sg7
I5
sg8
S'IPV6_UNICAST_HOPS'
p237
sa(dp238
g3
I01
sg7
I5
sg8
S'IPV6_V6ONLY'
p239
sa(dp240
g3
I01
sg7
I5
sg8
S'IP_ADD_MEMBERSHIP'
p241
sa(dp242
g3
I01
sg7
I5
sg8
S'IP_DEFAULT_MULTICAST_LOOP'
p243
sa(dp244
g3
I01
sg7
I5
sg8
S'IP_DEFAULT_MULTICAST_TTL'
p245
sa(dp246
g3
I01
sg7
I5
sg8
S'IP_DROP_MEMBERSHIP'
p247
sa(dp248
g3
I01
sg7
I5
sg8
S'IP_HDRINCL'
p249
sa(dp250
g3
I01
sg7
I5
sg8
S'IP_MAX_MEMBERSHIPS'
p251
sa(dp252
g3
I01
sg7
I5
sg8
S'IP_MULTICAST_IF'
p253
sa(dp254
g3
I01
sg7
I5
sg8
S'IP_MULTICAST_LOOP'
p255
sa(dp256
g3
I01
sg7
I5
sg8
S'IP_MULTICAST_TTL'
p257
sa(dp258
g3
I01
sg7
I5
sg8
S'IP_OPTIONS'
p259
sa(dp260
g3
I01
sg7
I5
sg8
S'IP_RECVOPTS'
p261
sa(dp262
g3
I01
sg7
I5
sg8
S'IP_RECVRETOPTS'
p263
sa(dp264
g3
I01
sg7
I5
sg8
S'IP_RETOPTS'
p265
sa(dp266
g3
I01
sg7
I5
sg8
S'IP_TOS'
p267
sa(dp268
g3
I01
sg7
I5
sg8
S'IP_TTL'
p269
sa(dp270
g3
I01
sg7
I5
sg8
S'MSG_CTRUNC'
p271
sa(dp272
g3
I01
sg7
I5
sg8
S'MSG_DONTROUTE'
p273
sa(dp274
g3
I01
sg7
I5
sg8
S'MSG_DONTWAIT'
p275
sa(dp276
g3
I01
sg7
I5
sg8
S'MSG_EOR'
p277
sa(dp278
g3
I01
sg7
I5
sg8
S'MSG_OOB'
p279
sa(dp280
g3
I01
sg7
I5
sg8
S'MSG_PEEK'
p281
sa(dp282
g3
I01
sg7
I5
sg8
S'MSG_TRUNC'
p283
sa(dp284
g3
I01
sg7
I5
sg8
S'MSG_WAITALL'
p285
sa(dp286
g3
I01
sg7
I5
sg8
S'NETLINK_DNRTMSG'
p287
sa(dp288
g3
I01
sg7
I5
sg8
S'NETLINK_FIREWALL'
p289
sa(dp290
g3
I01
sg7
I5
sg8
S'NETLINK_IP6_FW'
p291
sa(dp292
g3
I01
sg7
I5
sg8
S'NETLINK_NFLOG'
p293
sa(dp294
g3
I01
sg7
I5
sg8
S'NETLINK_ROUTE'
p295
sa(dp296
g3
I01
sg7
I5
sg8
S'NETLINK_USERSOCK'
p297
sa(dp298
g3
I01
sg7
I5
sg8
S'NETLINK_XFRM'
p299
sa(dp300
g3
I01
sg7
I5
sg8
S'NI_DGRAM'
p301
sa(dp302
g3
I01
sg7
I5
sg8
S'NI_MAXHOST'
p303
sa(dp304
g3
I01
sg7
I5
sg8
S'NI_MAXSERV'
p305
sa(dp306
g3
I01
sg7
I5
sg8
S'NI_NAMEREQD'
p307
sa(dp308
g3
I01
sg7
I5
sg8
S'NI_NOFQDN'
p309
sa(dp310
g3
I01
sg7
I5
sg8
S'NI_NUMERICHOST'
p311
sa(dp312
g3
I01
sg7
I5
sg8
S'NI_NUMERICSERV'
p313
sa(dp314
g3
I01
sg7
I5
sg8
S'PACKET_BROADCAST'
p315
sa(dp316
g3
I01
sg7
I5
sg8
S'PACKET_FASTROUTE'
p317
sa(dp318
g3
I01
sg7
I5
sg8
S'PACKET_HOST'
p319
sa(dp320
g3
I01
sg7
I5
sg8
S'PACKET_LOOPBACK'
p321
sa(dp322
g3
I01
sg7
I5
sg8
S'PACKET_MULTICAST'
p323
sa(dp324
g3
I01
sg7
I5
sg8
S'PACKET_OTHERHOST'
p325
sa(dp326
g3
I01
sg7
I5
sg8
S'PACKET_OUTGOING'
p327
sa(dp328
g3
I01
sg7
I5
sg8
S'PF_PACKET'
p329
sa(dp330
g3
I01
sg7
I5
sg8
S'SHUT_RD'
p331
sa(dp332
g3
I01
sg7
I5
sg8
S'SHUT_RDWR'
p333
sa(dp334
g3
I01
sg7
I5
sg8
S'SHUT_WR'
p335
sa(dp336
g3
I01
sg7
I5
sg8
S'SOCK_DGRAM'
p337
sa(dp338
g3
I01
sg7
I5
sg8
S'SOCK_RAW'
p339
sa(dp340
g3
I01
sg7
I5
sg8
S'SOCK_RDM'
p341
sa(dp342
g3
I01
sg7
I5
sg8
S'SOCK_SEQPACKET'
p343
sa(dp344
g3
I01
sg7
I5
sg8
S'SOCK_STREAM'
p345
sa(dp346
g3
I01
sg7
I5
sg8
S'SOL_HCI'
p347
sa(dp348
g3
I01
sg7
I5
sg8
S'SOL_IP'
p349
sa(dp350
g3
I01
sg7
I5
sg8
S'SOL_SOCKET'
p351
sa(dp352
g3
I01
sg7
I5
sg8
S'SOL_TCP'
p353
sa(dp354
g3
I01
sg7
I5
sg8
S'SOL_TIPC'
p355
sa(dp356
g3
I01
sg7
I5
sg8
S'SOL_UDP'
p357
sa(dp358
g3
I01
sg7
I5
sg8
S'SOMAXCONN'
p359
sa(dp360
g3
I01
sg7
I5
sg8
S'SO_ACCEPTCONN'
p361
sa(dp362
g3
I01
sg7
I5
sg8
S'SO_BROADCAST'
p363
sa(dp364
g3
I01
sg7
I5
sg8
S'SO_DEBUG'
p365
sa(dp366
g3
I01
sg7
I5
sg8
S'SO_DONTROUTE'
p367
sa(dp368
g3
I01
sg7
I5
sg8
S'SO_ERROR'
p369
sa(dp370
g3
I01
sg7
I5
sg8
S'SO_KEEPALIVE'
p371
sa(dp372
g3
I01
sg7
I5
sg8
S'SO_LINGER'
p373
sa(dp374
g3
I01
sg7
I5
sg8
S'SO_OOBINLINE'
p375
sa(dp376
g3
I01
sg7
I5
sg8
S'SO_RCVBUF'
p377
sa(dp378
g3
I01
sg7
I5
sg8
S'SO_RCVLOWAT'
p379
sa(dp380
g3
I01
sg7
I5
sg8
S'SO_RCVTIMEO'
p381
sa(dp382
g3
I01
sg7
I5
sg8
S'SO_REUSEADDR'
p383
sa(dp384
g3
I01
sg7
I5
sg8
S'SO_REUSEPORT'
p385
sa(dp386
g3
I01
sg7
I5
sg8
S'SO_SNDBUF'
p387
sa(dp388
g3
I01
sg7
I5
sg8
S'SO_SNDLOWAT'
p389
sa(dp390
g3
I01
sg7
I5
sg8
S'SO_SNDTIMEO'
p391
sa(dp392
g3
I01
sg7
I5
sg8
S'SO_TYPE'
p393
sa(dp394
g1
S"socket([family[, type[, proto]]]) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\naccept() -- accept a connection, returning new socket and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket object identical to the current one [*]\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten(n) -- start listening for incoming connections\nmakefile([mode, [bufsize]]) -- return a file object for the socket [*]\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(0 | 1) -- set or clear the blocking I/O flag\nsetsockopt(level, optname, value) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!"
p395
sg3
I01
sg4
(lp396
(dp397
g3
I01
sg7
I5
sg8
S'__delattr__'
p398
sa(dp399
g3
I01
sg7
I5
sg8
S'__doc__'
p400
sa(dp401
g1
S'default object formatter'
p402
sg3
I01
sg7
I2
sg8
S'__format__'
p403
sa(dp404
g3
I01
sg7
I5
sg8
S'__getattribute__'
p405
sa(dp406
g3
I01
sg7
I5
sg8
S'__hash__'
p407
sa(dp408
g3
I01
sg7
I5
sg8
S'__init__'
p409
sa(dp410
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p411
sg3
I01
sg7
I2
sg8
S'__new__'
p412
sa(dp413
g1
S'helper for pickle'
p414
sg3
I01
sg7
I2
sg8
S'__reduce__'
p415
sa(dp416
g1
S'helper for pickle'
p417
sg3
I01
sg7
I2
sg8
S'__reduce_ex__'
p418
sa(dp419
g3
I01
sg7
I5
sg8
S'__repr__'
p420
sa(dp421
g3
I01
sg7
I5
sg8
S'__setattr__'
p422
sa(dp423
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p424
sg3
I01
sg7
I2
sg8
S'__sizeof__'
p425
sa(dp426
g3
I01
sg7
I5
sg8
S'__str__'
p427
sa(dp428
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p429
sg3
I01
sg7
I2
sg8
S'__subclasshook__'
p430
sa(dp431
g1
S'accept() -> (socket object, address info)\n\nWait for an incoming connection.  Return a new socket representing the\nconnection, and the address of the client.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p432
sg3
I01
sg7
I2
sg8
S'accept'
p433
sa(dp434
g1
S'bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype]])'
p435
sg3
I01
sg7
I2
sg8
S'bind'
p436
sa(dp437
g1
S'close()\n\nClose the socket.  It cannot be used after this call.'
p438
sg3
I01
sg7
I2
sg8
S'close'
p439
sa(dp440
g1
S'connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).'
p441
sg3
I01
sg7
I2
sg8
S'connect'
p442
sa(dp443
g1
S'connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.'
p444
sg3
I01
sg7
I2
sg8
S'connect_ex'
p445
sa(dp446
g1
S'dup() -> socket object\n\nReturn a new socket object connected to the same system resource.'
p447
sg3
I01
sg7
I2
sg8
S'dup'
p448
sa(dp449
g3
I01
sg7
I5
sg8
S'family'
p450
sa(dp451
g1
S'fileno() -> integer\n\nReturn the integer file descriptor of the socket.'
p452
sg3
I01
sg7
I2
sg8
S'fileno'
p453
sa(dp454
g1
S'getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p455
sg3
I01
sg7
I2
sg8
S'getpeername'
p456
sa(dp457
g1
S'getsockname() -> address info\n\nReturn the address of the local endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p458
sg3
I01
sg7
I2
sg8
S'getsockname'
p459
sa(dp460
g1
S'getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.'
p461
sg3
I01
sg7
I2
sg8
S'getsockopt'
p462
sa(dp463
g1
S'gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket \noperations. A timeout of None indicates that timeouts on socket \noperations are disabled.'
p464
sg3
I01
sg7
I2
sg8
S'gettimeout'
p465
sa(dp466
g1
S'listen(backlog)\n\nEnable a server to accept connections.  The backlog argument must be at\nleast 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections.'
p467
sg3
I01
sg7
I2
sg8
S'listen'
p468
sa(dp469
g1
S'makefile([mode[, buffersize]]) -> file object\n\nReturn a regular file object corresponding to the socket.\nThe mode and buffersize arguments are as for the built-in open() function.'
p470
sg3
I01
sg7
I2
sg8
S'makefile'
p471
sa(dp472
g3
I01
sg7
I5
sg8
S'proto'
p473
sa(dp474
g1
S'recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.'
p475
sg3
I01
sg7
I2
sg8
S'recv'
p476
sa(dp477
g1
S'recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating \na new string.  Receive up to buffersize bytes from the socket.  If buffersize \nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.'
p478
sg3
I01
sg7
I2
sg8
S'recv_into'
p479
sa(dp480
g1
S"recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info."
p481
sg3
I01
sg7
I2
sg8
S'recvfrom'
p482
sa(dp483
g1
S"recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info."
p484
sg3
I01
sg7
I2
sg8
S'recvfrom_into'
p485
sa(dp486
g1
S'send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.'
p487
sg3
I01
sg7
I2
sg8
S'send'
p488
sa(dp489
g1
S"sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent."
p490
sg3
I01
sg7
I2
sg8
S'sendall'
p491
sa(dp492
g1
S'sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).'
p493
sg3
I01
sg7
I2
sg8
S'sendto'
p494
sa(dp495
g1
S'setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).'
p496
sg3
I01
sg7
I2
sg8
S'setblocking'
p497
sa(dp498
g1
S'setsockopt(level, option, value)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer or a string.'
p499
sg3
I01
sg7
I2
sg8
S'setsockopt'
p500
sa(dp501
g1
S"settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0)."
p502
sg3
I01
sg7
I2
sg8
S'settimeout'
p503
sa(dp504
g1
S'shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).'
p505
sg3
I01
sg7
I2
sg8
S'shutdown'
p506
sa(dp507
g3
I01
sg7
I5
sg8
S'timeout'
p508
sa(dp509
g3
I01
sg7
I5
sg8
g7
sasg7
I3
sg8
S'SocketType'
p510
sa(dp511
g3
I01
sg7
I5
sg8
S'TCP_CORK'
p512
sa(dp513
g3
I01
sg7
I5
sg8
S'TCP_DEFER_ACCEPT'
p514
sa(dp515
g3
I01
sg7
I5
sg8
S'TCP_INFO'
p516
sa(dp517
g3
I01
sg7
I5
sg8
S'TCP_KEEPCNT'
p518
sa(dp519
g3
I01
sg7
I5
sg8
S'TCP_KEEPIDLE'
p520
sa(dp521
g3
I01
sg7
I5
sg8
S'TCP_KEEPINTVL'
p522
sa(dp523
g3
I01
sg7
I5
sg8
S'TCP_LINGER2'
p524
sa(dp525
g3
I01
sg7
I5
sg8
S'TCP_MAXSEG'
p526
sa(dp527
g3
I01
sg7
I5
sg8
S'TCP_NODELAY'
p528
sa(dp529
g3
I01
sg7
I5
sg8
S'TCP_QUICKACK'
p530
sa(dp531
g3
I01
sg7
I5
sg8
S'TCP_SYNCNT'
p532
sa(dp533
g3
I01
sg7
I5
sg8
S'TCP_WINDOW_CLAMP'
p534
sa(dp535
g3
I01
sg7
I5
sg8
S'TIPC_ADDR_ID'
p536
sa(dp537
g3
I01
sg7
I5
sg8
S'TIPC_ADDR_NAME'
p538
sa(dp539
g3
I01
sg7
I5
sg8
S'TIPC_ADDR_NAMESEQ'
p540
sa(dp541
g3
I01
sg7
I5
sg8
S'TIPC_CFG_SRV'
p542
sa(dp543
g3
I01
sg7
I5
sg8
S'TIPC_CLUSTER_SCOPE'
p544
sa(dp545
g3
I01
sg7
I5
sg8
S'TIPC_CONN_TIMEOUT'
p546
sa(dp547
g3
I01
sg7
I5
sg8
S'TIPC_CRITICAL_IMPORTANCE'
p548
sa(dp549
g3
I01
sg7
I5
sg8
S'TIPC_DEST_DROPPABLE'
p550
sa(dp551
g3
I01
sg7
I5
sg8
S'TIPC_HIGH_IMPORTANCE'
p552
sa(dp553
g3
I01
sg7
I5
sg8
S'TIPC_IMPORTANCE'
p554
sa(dp555
g3
I01
sg7
I5
sg8
S'TIPC_LOW_IMPORTANCE'
p556
sa(dp557
g3
I01
sg7
I5
sg8
S'TIPC_MEDIUM_IMPORTANCE'
p558
sa(dp559
g3
I01
sg7
I5
sg8
S'TIPC_NODE_SCOPE'
p560
sa(dp561
g3
I01
sg7
I5
sg8
S'TIPC_PUBLISHED'
p562
sa(dp563
g3
I01
sg7
I5
sg8
S'TIPC_SRC_DROPPABLE'
p564
sa(dp565
g3
I01
sg7
I5
sg8
S'TIPC_SUBSCR_TIMEOUT'
p566
sa(dp567
g3
I01
sg7
I5
sg8
S'TIPC_SUB_CANCEL'
p568
sa(dp569
g3
I01
sg7
I5
sg8
S'TIPC_SUB_PORTS'
p570
sa(dp571
g3
I01
sg7
I5
sg8
S'TIPC_SUB_SERVICE'
p572
sa(dp573
g3
I01
sg7
I5
sg8
S'TIPC_TOP_SRV'
p574
sa(dp575
g3
I01
sg7
I5
sg8
S'TIPC_WAIT_FOREVER'
p576
sa(dp577
g3
I01
sg7
I5
sg8
S'TIPC_WITHDRAWN'
p578
sa(dp579
g3
I01
sg7
I5
sg8
S'TIPC_ZONE_SCOPE'
p580
sa(dp581
g3
I01
sg7
I5
sg8
g400
sa(dp582
g3
I01
sg7
I5
sg8
S'__name__'
p583
sa(dp584
g3
I01
sg7
I5
sg8
S'__package__'
p585
sa(dp586
g1
Nsg3
I01
sg4
(lp587
(dp588
g3
I01
sg7
I5
sg8
g398
sa(dp589
g3
I01
sg7
I5
sg8
S'__dict__'
p590
sa(dp591
g3
I01
sg7
I5
sg8
g400
sa(dp592
g1
S'default object formatter'
p593
sg3
I01
sg7
I2
sg8
g403
sa(dp594
g3
I01
sg7
I5
sg8
g405
sa(dp595
g3
I01
sg7
I5
sg8
S'__getitem__'
p596
sa(dp597
g3
I01
sg7
I5
sg8
S'__getslice__'
p598
sa(dp599
g3
I01
sg7
I5
sg8
g407
sa(dp600
g3
I01
sg7
I5
sg8
g409
sa(dp601
g3
I01
sg7
I5
sg8
S'__module__'
p602
sa(dp603
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p604
sg3
I01
sg7
I2
sg8
g412
sa(dp605
g1
Nsg3
I01
sg7
I2
sg8
g415
sa(dp606
g1
S'helper for pickle'
p607
sg3
I01
sg7
I2
sg8
g418
sa(dp608
g3
I01
sg7
I5
sg8
g420
sa(dp609
g3
I01
sg7
I5
sg8
g422
sa(dp610
g1
Nsg3
I01
sg7
I2
sg8
S'__setstate__'
p611
sa(dp612
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p613
sg3
I01
sg7
I2
sg8
g425
sa(dp614
g3
I01
sg7
I5
sg8
g427
sa(dp615
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p616
sg3
I01
sg7
I2
sg8
g430
sa(dp617
g1
Nsg3
I01
sg7
I2
sg8
S'__unicode__'
p618
sa(dp619
g3
I01
sg7
I5
sg8
S'__weakref__'
p620
sa(dp621
g3
I01
sg7
I5
sg8
S'args'
p622
sa(dp623
g3
I01
sg7
I5
sg8
S'errno'
p624
sa(dp625
g3
I01
sg7
I5
sg8
S'filename'
p626
sa(dp627
g3
I01
sg7
I5
sg8
S'message'
p628
sa(dp629
g3
I01
sg7
I5
sg8
S'strerror'
p630
sasg7
I3
sg8
S'error'
p631
sa(dp632
g1
S'fromfd(fd, family, type[, proto]) -> socket object\n\nCreate a socket object from a duplicate of the given\nfile descriptor.\nThe remaining arguments are the same as for socket().'
p633
sg3
I01
sg7
I2
sg8
S'fromfd'
p634
sa(dp635
g1
Nsg3
I01
sg4
(lp636
(dp637
g3
I01
sg7
I5
sg8
g398
sa(dp638
g3
I01
sg7
I5
sg8
g590
sa(dp639
g3
I01
sg7
I5
sg8
g400
sa(dp640
g1
S'default object formatter'
p641
sg3
I01
sg7
I2
sg8
g403
sa(dp642
g3
I01
sg7
I5
sg8
g405
sa(dp643
g3
I01
sg7
I5
sg8
g596
sa(dp644
g3
I01
sg7
I5
sg8
g598
sa(dp645
g3
I01
sg7
I5
sg8
g407
sa(dp646
g3
I01
sg7
I5
sg8
g409
sa(dp647
g3
I01
sg7
I5
sg8
g602
sa(dp648
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p649
sg3
I01
sg7
I2
sg8
g412
sa(dp650
g1
Nsg3
I01
sg7
I2
sg8
g415
sa(dp651
g1
S'helper for pickle'
p652
sg3
I01
sg7
I2
sg8
g418
sa(dp653
g3
I01
sg7
I5
sg8
g420
sa(dp654
g3
I01
sg7
I5
sg8
g422
sa(dp655
g1
Nsg3
I01
sg7
I2
sg8
g611
sa(dp656
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p657
sg3
I01
sg7
I2
sg8
g425
sa(dp658
g3
I01
sg7
I5
sg8
g427
sa(dp659
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p660
sg3
I01
sg7
I2
sg8
g430
sa(dp661
g1
Nsg3
I01
sg7
I2
sg8
g618
sa(dp662
g3
I01
sg7
I5
sg8
g620
sa(dp663
g3
I01
sg7
I5
sg8
g622
sa(dp664
g3
I01
sg7
I5
sg8
g624
sa(dp665
g3
I01
sg7
I5
sg8
g626
sa(dp666
g3
I01
sg7
I5
sg8
g628
sa(dp667
g3
I01
sg7
I5
sg8
g630
sasg7
I3
sg8
S'gaierror'
p668
sa(dp669
g1
S'getaddrinfo(host, port [, family, socktype, proto, flags])\n    -> list of (family, socktype, proto, canonname, sockaddr)\n\nResolve host and port into addrinfo struct.'
p670
sg3
I01
sg7
I2
sg8
S'getaddrinfo'
p671
sa(dp672
g1
S'getdefaulttimeout() -> timeout\n\nReturns the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.'
p673
sg3
I01
sg7
I2
sg8
S'getdefaulttimeout'
p674
sa(dp675
g1
S'gethostbyaddr(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.'
p676
sg3
I01
sg7
I2
sg8
S'gethostbyaddr'
p677
sa(dp678
g1
S"gethostbyname(host) -> address\n\nReturn the IP address (a string of the form '255.255.255.255') for a host."
p679
sg3
I01
sg7
I2
sg8
S'gethostbyname'
p680
sa(dp681
g1
S'gethostbyname_ex(host) -> (name, aliaslist, addresslist)\n\nReturn the true host name, a list of aliases, and a list of IP addresses,\nfor a host.  The host argument is a string giving a host name or IP number.'
p682
sg3
I01
sg7
I2
sg8
S'gethostbyname_ex'
p683
sa(dp684
g1
S'gethostname() -> string\n\nReturn the current host name.'
p685
sg3
I01
sg7
I2
sg8
S'gethostname'
p686
sa(dp687
g1
S'getnameinfo(sockaddr, flags) --> (host, port)\n\nGet host and port for a sockaddr.'
p688
sg3
I01
sg7
I2
sg8
S'getnameinfo'
p689
sa(dp690
g1
S'getprotobyname(name) -> integer\n\nReturn the protocol number for the named protocol.  (Rarely used.)'
p691
sg3
I01
sg7
I2
sg8
S'getprotobyname'
p692
sa(dp693
g1
S"getservbyname(servicename[, protocolname]) -> integer\n\nReturn a port number from a service name and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match."
p694
sg3
I01
sg7
I2
sg8
S'getservbyname'
p695
sa(dp696
g1
S"getservbyport(port[, protocolname]) -> string\n\nReturn the service name from a port number and protocol name.\nThe optional protocol name, if given, should be 'tcp' or 'udp',\notherwise any protocol will match."
p697
sg3
I01
sg7
I2
sg8
S'getservbyport'
p698
sa(dp699
g3
I01
sg7
I5
sg8
S'has_ipv6'
p700
sa(dp701
g1
Nsg3
I01
sg4
(lp702
(dp703
g3
I01
sg7
I5
sg8
g398
sa(dp704
g3
I01
sg7
I5
sg8
g590
sa(dp705
g3
I01
sg7
I5
sg8
g400
sa(dp706
g1
S'default object formatter'
p707
sg3
I01
sg7
I2
sg8
g403
sa(dp708
g3
I01
sg7
I5
sg8
g405
sa(dp709
g3
I01
sg7
I5
sg8
g596
sa(dp710
g3
I01
sg7
I5
sg8
g598
sa(dp711
g3
I01
sg7
I5
sg8
g407
sa(dp712
g3
I01
sg7
I5
sg8
g409
sa(dp713
g3
I01
sg7
I5
sg8
g602
sa(dp714
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p715
sg3
I01
sg7
I2
sg8
g412
sa(dp716
g1
Nsg3
I01
sg7
I2
sg8
g415
sa(dp717
g1
S'helper for pickle'
p718
sg3
I01
sg7
I2
sg8
g418
sa(dp719
g3
I01
sg7
I5
sg8
g420
sa(dp720
g3
I01
sg7
I5
sg8
g422
sa(dp721
g1
Nsg3
I01
sg7
I2
sg8
g611
sa(dp722
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p723
sg3
I01
sg7
I2
sg8
g425
sa(dp724
g3
I01
sg7
I5
sg8
g427
sa(dp725
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p726
sg3
I01
sg7
I2
sg8
g430
sa(dp727
g1
Nsg3
I01
sg7
I2
sg8
g618
sa(dp728
g3
I01
sg7
I5
sg8
g620
sa(dp729
g3
I01
sg7
I5
sg8
g622
sa(dp730
g3
I01
sg7
I5
sg8
g624
sa(dp731
g3
I01
sg7
I5
sg8
g626
sa(dp732
g3
I01
sg7
I5
sg8
g628
sa(dp733
g3
I01
sg7
I5
sg8
g630
sasg7
I3
sg8
S'herror'
p734
sa(dp735
g1
S'htonl(integer) -> integer\n\nConvert a 32-bit integer from host to network byte order.'
p736
sg3
I01
sg7
I2
sg8
S'htonl'
p737
sa(dp738
g1
S'htons(integer) -> integer\n\nConvert a 16-bit integer from host to network byte order.'
p739
sg3
I01
sg7
I2
sg8
S'htons'
p740
sa(dp741
g1
S'inet_aton(string) -> packed 32-bit IP representation\n\nConvert an IP address in string format (123.45.67.89) to the 32-bit packed\nbinary format used in low-level network functions.'
p742
sg3
I01
sg7
I2
sg8
S'inet_aton'
p743
sa(dp744
g1
S'inet_ntoa(packed_ip) -> ip_address_string\n\nConvert an IP address from 32-bit packed binary format to string format'
p745
sg3
I01
sg7
I2
sg8
S'inet_ntoa'
p746
sa(dp747
g1
S'inet_ntop(af, packed_ip) -> string formatted IP address\n\nConvert a packed IP address of the given family to string format.'
p748
sg3
I01
sg7
I2
sg8
S'inet_ntop'
p749
sa(dp750
g1
S'inet_pton(af, ip) -> packed IP address string\n\nConvert an IP address from string format to a packed string suitable\nfor use with low-level network functions.'
p751
sg3
I01
sg7
I2
sg8
S'inet_pton'
p752
sa(dp753
g1
S'ntohl(integer) -> integer\n\nConvert a 32-bit integer from network to host byte order.'
p754
sg3
I01
sg7
I2
sg8
S'ntohl'
p755
sa(dp756
g1
S'ntohs(integer) -> integer\n\nConvert a 16-bit integer from network to host byte order.'
p757
sg3
I01
sg7
I2
sg8
S'ntohs'
p758
sa(dp759
g1
S'setdefaulttimeout(timeout)\n\nSet the default timeout in seconds (float) for new socket objects.\nA value of None indicates that new socket objects have no timeout.\nWhen the socket module is first imported, the default is None.'
p760
sg3
I01
sg7
I2
sg8
S'setdefaulttimeout'
p761
sa(dp762
g1
S"socket([family[, type[, proto]]]) -> socket object\n\nOpen a socket of the given type.  The family argument specifies the\naddress family; it defaults to AF_INET.  The type argument specifies\nwhether this is a stream (SOCK_STREAM, this is the default)\nor datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\nspecifying the default protocol.  Keyword arguments are accepted.\n\nA socket object represents one endpoint of a network connection.\n\nMethods of socket objects (keyword arguments not allowed):\n\naccept() -- accept a connection, returning new socket and client address\nbind(addr) -- bind the socket to a local address\nclose() -- close the socket\nconnect(addr) -- connect the socket to a remote address\nconnect_ex(addr) -- connect, return an error code instead of an exception\ndup() -- return a new socket object identical to the current one [*]\nfileno() -- return underlying file descriptor\ngetpeername() -- return remote address [*]\ngetsockname() -- return local address\ngetsockopt(level, optname[, buflen]) -- get socket options\ngettimeout() -- return timeout or None\nlisten(n) -- start listening for incoming connections\nmakefile([mode, [bufsize]]) -- return a file object for the socket [*]\nrecv(buflen[, flags]) -- receive data\nrecv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\nrecvfrom(buflen[, flags]) -- receive data and sender's address\nrecvfrom_into(buffer[, nbytes, [, flags])\n  -- receive data and sender's address (into a buffer)\nsendall(data[, flags]) -- send all data\nsend(data[, flags]) -- send data, may not send all of it\nsendto(data[, flags], addr) -- send data to a given address\nsetblocking(0 | 1) -- set or clear the blocking I/O flag\nsetsockopt(level, optname, value) -- set socket options\nsettimeout(None | float) -- set or clear the timeout\nshutdown(how) -- shut down traffic in one or both directions\n\n [*] not available on all platforms!"
p763
sg3
I01
sg4
(lp764
(dp765
g3
I01
sg7
I5
sg8
g398
sa(dp766
g3
I01
sg7
I5
sg8
g400
sa(dp767
g1
S'default object formatter'
p768
sg3
I01
sg7
I2
sg8
g403
sa(dp769
g3
I01
sg7
I5
sg8
g405
sa(dp770
g3
I01
sg7
I5
sg8
g407
sa(dp771
g3
I01
sg7
I5
sg8
g409
sa(dp772
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p773
sg3
I01
sg7
I2
sg8
g412
sa(dp774
g1
S'helper for pickle'
p775
sg3
I01
sg7
I2
sg8
g415
sa(dp776
g1
S'helper for pickle'
p777
sg3
I01
sg7
I2
sg8
g418
sa(dp778
g3
I01
sg7
I5
sg8
g420
sa(dp779
g3
I01
sg7
I5
sg8
g422
sa(dp780
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p781
sg3
I01
sg7
I2
sg8
g425
sa(dp782
g3
I01
sg7
I5
sg8
g427
sa(dp783
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p784
sg3
I01
sg7
I2
sg8
g430
sa(dp785
g1
S'accept() -> (socket object, address info)\n\nWait for an incoming connection.  Return a new socket representing the\nconnection, and the address of the client.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p786
sg3
I01
sg7
I2
sg8
g433
sa(dp787
g1
S'bind(address)\n\nBind the socket to a local address.  For IP sockets, the address is a\npair (host, port); the host must refer to the local host. For raw packet\nsockets the address is a tuple (ifname, proto [,pkttype [,hatype]])'
p788
sg3
I01
sg7
I2
sg8
g436
sa(dp789
g1
S'close()\n\nClose the socket.  It cannot be used after this call.'
p790
sg3
I01
sg7
I2
sg8
g439
sa(dp791
g1
S'connect(address)\n\nConnect the socket to a remote address.  For IP sockets, the address\nis a pair (host, port).'
p792
sg3
I01
sg7
I2
sg8
g442
sa(dp793
g1
S'connect_ex(address) -> errno\n\nThis is like connect(address), but returns an error code (the errno value)\ninstead of raising an exception when an error occurs.'
p794
sg3
I01
sg7
I2
sg8
g445
sa(dp795
g1
S'dup() -> socket object\n\nReturn a new socket object connected to the same system resource.'
p796
sg3
I01
sg7
I2
sg8
g448
sa(dp797
g3
I01
sg7
I5
sg8
g450
sa(dp798
g1
S'fileno() -> integer\n\nReturn the integer file descriptor of the socket.'
p799
sg3
I01
sg7
I2
sg8
g453
sa(dp800
g1
S'getpeername() -> address info\n\nReturn the address of the remote endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p801
sg3
I01
sg7
I2
sg8
g456
sa(dp802
g1
S'getsockname() -> address info\n\nReturn the address of the local endpoint.  For IP sockets, the address\ninfo is a pair (hostaddr, port).'
p803
sg3
I01
sg7
I2
sg8
g459
sa(dp804
g1
S'getsockopt(level, option[, buffersize]) -> value\n\nGet a socket option.  See the Unix manual for level and option.\nIf a nonzero buffersize argument is given, the return value is a\nstring of that length; otherwise it is an integer.'
p805
sg3
I01
sg7
I2
sg8
g462
sa(dp806
g1
S'gettimeout() -> timeout\n\nReturns the timeout in seconds (float) associated with socket \noperations. A timeout of None indicates that timeouts on socket \noperations are disabled.'
p807
sg3
I01
sg7
I2
sg8
g465
sa(dp808
g1
S'listen(backlog)\n\nEnable a server to accept connections.  The backlog argument must be at\nleast 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections.'
p809
sg3
I01
sg7
I2
sg8
g468
sa(dp810
g1
S'makefile([mode[, buffersize]]) -> file object\n\nReturn a regular file object corresponding to the socket.\nThe mode and buffersize arguments are as for the built-in open() function.'
p811
sg3
I01
sg7
I2
sg8
g471
sa(dp812
g3
I01
sg7
I5
sg8
g473
sa(dp813
g1
S'recv(buffersize[, flags]) -> data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.'
p814
sg3
I01
sg7
I2
sg8
g476
sa(dp815
g1
S'recv_into(buffer, [nbytes[, flags]]) -> nbytes_read\n\nA version of recv() that stores its data into a buffer rather than creating \na new string.  Receive up to buffersize bytes from the socket.  If buffersize \nis not specified (or 0), receive up to the size available in the given buffer.\n\nSee recv() for documentation about the flags.'
p816
sg3
I01
sg7
I2
sg8
g479
sa(dp817
g1
S"recvfrom(buffersize[, flags]) -> (data, address info)\n\nLike recv(buffersize, flags) but also return the sender's address info."
p818
sg3
I01
sg7
I2
sg8
g482
sa(dp819
g1
S"recvfrom_into(buffer[, nbytes[, flags]]) -> (nbytes, address info)\n\nLike recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info."
p820
sg3
I01
sg7
I2
sg8
g485
sa(dp821
g1
S'send(data[, flags]) -> count\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  Return the number of bytes\nsent; this may be less than len(data) if the network is busy.'
p822
sg3
I01
sg7
I2
sg8
g488
sa(dp823
g1
S"sendall(data[, flags])\n\nSend a data string to the socket.  For the optional flags\nargument, see the Unix manual.  This calls send() repeatedly\nuntil all data is sent.  If an error occurs, it's impossible\nto tell how much data has been sent."
p824
sg3
I01
sg7
I2
sg8
g491
sa(dp825
g1
S'sendto(data[, flags], address) -> count\n\nLike send(data, flags) but allows specifying the destination address.\nFor IP sockets, the address is a pair (hostaddr, port).'
p826
sg3
I01
sg7
I2
sg8
g494
sa(dp827
g1
S'setblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).'
p828
sg3
I01
sg7
I2
sg8
g497
sa(dp829
g1
S'setsockopt(level, option, value)\n\nSet a socket option.  See the Unix manual for level and option.\nThe value argument can either be an integer or a string.'
p830
sg3
I01
sg7
I2
sg8
g500
sa(dp831
g1
S"settimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0)."
p832
sg3
I01
sg7
I2
sg8
g503
sa(dp833
g1
S'shutdown(flag)\n\nShut down the reading side of the socket (flag == SHUT_RD), the writing side\nof the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).'
p834
sg3
I01
sg7
I2
sg8
g506
sa(dp835
g3
I01
sg7
I5
sg8
g508
sa(dp836
g3
I01
sg7
I5
sg8
g7
sasg7
I3
sg8
S'socket'
p837
sa(dp838
g1
S'socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is\nAF_UNIX if defined on the platform; otherwise, the default is AF_INET.'
p839
sg3
I01
sg7
I2
sg8
S'socketpair'
p840
sa(dp841
g1
Nsg3
I01
sg4
(lp842
(dp843
g3
I01
sg7
I5
sg8
g398
sa(dp844
g3
I01
sg7
I5
sg8
g590
sa(dp845
g3
I01
sg7
I5
sg8
g400
sa(dp846
g1
S'default object formatter'
p847
sg3
I01
sg7
I2
sg8
g403
sa(dp848
g3
I01
sg7
I5
sg8
g405
sa(dp849
g3
I01
sg7
I5
sg8
g596
sa(dp850
g3
I01
sg7
I5
sg8
g598
sa(dp851
g3
I01
sg7
I5
sg8
g407
sa(dp852
g3
I01
sg7
I5
sg8
g409
sa(dp853
g3
I01
sg7
I5
sg8
g602
sa(dp854
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p855
sg3
I01
sg7
I2
sg8
g412
sa(dp856
g1
Nsg3
I01
sg7
I2
sg8
g415
sa(dp857
g1
S'helper for pickle'
p858
sg3
I01
sg7
I2
sg8
g418
sa(dp859
g3
I01
sg7
I5
sg8
g420
sa(dp860
g3
I01
sg7
I5
sg8
g422
sa(dp861
g1
Nsg3
I01
sg7
I2
sg8
g611
sa(dp862
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p863
sg3
I01
sg7
I2
sg8
g425
sa(dp864
g3
I01
sg7
I5
sg8
g427
sa(dp865
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p866
sg3
I01
sg7
I2
sg8
g430
sa(dp867
g1
Nsg3
I01
sg7
I2
sg8
g618
sa(dp868
g3
I01
sg7
I5
sg8
g620
sa(dp869
g3
I01
sg7
I5
sg8
g622
sa(dp870
g3
I01
sg7
I5
sg8
g624
sa(dp871
g3
I01
sg7
I5
sg8
g626
sa(dp872
g3
I01
sg7
I5
sg8
g628
sa(dp873
g3
I01
sg7
I5
sg8
g630
sasg7
I3
sg8
g508
sasg8
S'_socket'
p874
s.