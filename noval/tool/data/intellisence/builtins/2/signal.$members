(dp0
S'doc'
p1
S'This module provides mechanisms to use signal handlers in Python.\n\nFunctions:\n\nalarm() -- cause SIGALRM after a specified time [Unix only]\nsetitimer() -- cause a signal (described below) after a specified\n               float time and the timer may restart then [Unix only]\ngetitimer() -- get current value of timer [Unix only]\nsignal() -- set the action for a given signal\ngetsignal() -- get the signal action for a given signal\npause() -- wait until a signal arrives [Unix only]\ndefault_int_handler() -- default SIGINT handler\n\nsignal constants:\nSIG_DFL -- used to refer to the system default handler\nSIG_IGN -- used to ignore the signal\nNSIG -- number of defined signals\nSIGINT, SIGTERM, etc. -- signal numbers\n\nitimer constants:\nITIMER_REAL -- decrements in real time, and delivers SIGALRM upon\n               expiration\nITIMER_VIRTUAL -- decrements only when the process is executing,\n               and delivers SIGVTALRM upon expiration\nITIMER_PROF -- decrements both when the process is executing and\n               when the system is executing on behalf of the process.\n               Coupled with ITIMER_VIRTUAL, this timer is usually\n               used to profile the time spent by the application\n               in user and kernel space. SIGPROF is delivered upon\n               expiration.\n\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'ITIMER_PROF'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'ITIMER_REAL'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'ITIMER_VIRTUAL'
p13
sa(dp14
g1
Nsg3
I01
sg4
(lp15
(dp16
g3
I01
sg7
I5
sg8
S'__delattr__'
p17
sa(dp18
g3
I01
sg7
I5
sg8
S'__dict__'
p19
sa(dp20
g3
I01
sg7
I5
sg8
S'__doc__'
p21
sa(dp22
g1
S'default object formatter'
p23
sg3
I01
sg7
I2
sg8
S'__format__'
p24
sa(dp25
g3
I01
sg7
I5
sg8
S'__getattribute__'
p26
sa(dp27
g3
I01
sg7
I5
sg8
S'__getitem__'
p28
sa(dp29
g3
I01
sg7
I5
sg8
S'__getslice__'
p30
sa(dp31
g3
I01
sg7
I5
sg8
S'__hash__'
p32
sa(dp33
g3
I01
sg7
I5
sg8
S'__init__'
p34
sa(dp35
g3
I01
sg7
I5
sg8
S'__module__'
p36
sa(dp37
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p38
sg3
I01
sg7
I2
sg8
S'__new__'
p39
sa(dp40
g1
Nsg3
I01
sg7
I2
sg8
S'__reduce__'
p41
sa(dp42
g1
S'helper for pickle'
p43
sg3
I01
sg7
I2
sg8
S'__reduce_ex__'
p44
sa(dp45
g3
I01
sg7
I5
sg8
S'__repr__'
p46
sa(dp47
g3
I01
sg7
I5
sg8
S'__setattr__'
p48
sa(dp49
g1
Nsg3
I01
sg7
I2
sg8
S'__setstate__'
p50
sa(dp51
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p52
sg3
I01
sg7
I2
sg8
S'__sizeof__'
p53
sa(dp54
g3
I01
sg7
I5
sg8
S'__str__'
p55
sa(dp56
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p57
sg3
I01
sg7
I2
sg8
S'__subclasshook__'
p58
sa(dp59
g1
Nsg3
I01
sg7
I2
sg8
S'__unicode__'
p60
sa(dp61
g3
I01
sg7
I5
sg8
S'__weakref__'
p62
sa(dp63
g3
I01
sg7
I5
sg8
S'args'
p64
sa(dp65
g3
I01
sg7
I5
sg8
S'errno'
p66
sa(dp67
g3
I01
sg7
I5
sg8
S'filename'
p68
sa(dp69
g3
I01
sg7
I5
sg8
S'message'
p70
sa(dp71
g3
I01
sg7
I5
sg8
S'strerror'
p72
sasg7
I3
sg8
S'ItimerError'
p73
sa(dp74
g3
I01
sg7
I5
sg8
S'NSIG'
p75
sa(dp76
g3
I01
sg7
I5
sg8
S'SIGABRT'
p77
sa(dp78
g3
I01
sg7
I5
sg8
S'SIGALRM'
p79
sa(dp80
g3
I01
sg7
I5
sg8
S'SIGBUS'
p81
sa(dp82
g3
I01
sg7
I5
sg8
S'SIGCHLD'
p83
sa(dp84
g3
I01
sg7
I5
sg8
S'SIGCLD'
p85
sa(dp86
g3
I01
sg7
I5
sg8
S'SIGCONT'
p87
sa(dp88
g3
I01
sg7
I5
sg8
S'SIGFPE'
p89
sa(dp90
g3
I01
sg7
I5
sg8
S'SIGHUP'
p91
sa(dp92
g3
I01
sg7
I5
sg8
S'SIGILL'
p93
sa(dp94
g3
I01
sg7
I5
sg8
S'SIGINT'
p95
sa(dp96
g3
I01
sg7
I5
sg8
S'SIGIO'
p97
sa(dp98
g3
I01
sg7
I5
sg8
S'SIGIOT'
p99
sa(dp100
g3
I01
sg7
I5
sg8
S'SIGKILL'
p101
sa(dp102
g3
I01
sg7
I5
sg8
S'SIGPIPE'
p103
sa(dp104
g3
I01
sg7
I5
sg8
S'SIGPOLL'
p105
sa(dp106
g3
I01
sg7
I5
sg8
S'SIGPROF'
p107
sa(dp108
g3
I01
sg7
I5
sg8
S'SIGPWR'
p109
sa(dp110
g3
I01
sg7
I5
sg8
S'SIGQUIT'
p111
sa(dp112
g3
I01
sg7
I5
sg8
S'SIGRTMAX'
p113
sa(dp114
g3
I01
sg7
I5
sg8
S'SIGRTMIN'
p115
sa(dp116
g3
I01
sg7
I5
sg8
S'SIGSEGV'
p117
sa(dp118
g3
I01
sg7
I5
sg8
S'SIGSTOP'
p119
sa(dp120
g3
I01
sg7
I5
sg8
S'SIGSYS'
p121
sa(dp122
g3
I01
sg7
I5
sg8
S'SIGTERM'
p123
sa(dp124
g3
I01
sg7
I5
sg8
S'SIGTRAP'
p125
sa(dp126
g3
I01
sg7
I5
sg8
S'SIGTSTP'
p127
sa(dp128
g3
I01
sg7
I5
sg8
S'SIGTTIN'
p129
sa(dp130
g3
I01
sg7
I5
sg8
S'SIGTTOU'
p131
sa(dp132
g3
I01
sg7
I5
sg8
S'SIGURG'
p133
sa(dp134
g3
I01
sg7
I5
sg8
S'SIGUSR1'
p135
sa(dp136
g3
I01
sg7
I5
sg8
S'SIGUSR2'
p137
sa(dp138
g3
I01
sg7
I5
sg8
S'SIGVTALRM'
p139
sa(dp140
g3
I01
sg7
I5
sg8
S'SIGWINCH'
p141
sa(dp142
g3
I01
sg7
I5
sg8
S'SIGXCPU'
p143
sa(dp144
g3
I01
sg7
I5
sg8
S'SIGXFSZ'
p145
sa(dp146
g3
I01
sg7
I5
sg8
S'SIG_DFL'
p147
sa(dp148
g3
I01
sg7
I5
sg8
S'SIG_IGN'
p149
sa(dp150
g3
I01
sg7
I5
sg8
g21
sa(dp151
g3
I01
sg7
I5
sg8
S'__name__'
p152
sa(dp153
g3
I01
sg7
I5
sg8
S'__package__'
p154
sa(dp155
g1
S'alarm(seconds)\n\nArrange for SIGALRM to arrive after the given number of seconds.'
p156
sg3
I01
sg7
I2
sg8
S'alarm'
p157
sa(dp158
g1
S'default_int_handler(...)\n\nThe default handler for SIGINT installed by Python.\nIt raises KeyboardInterrupt.'
p159
sg3
I01
sg7
I2
sg8
S'default_int_handler'
p160
sa(dp161
g1
S'getitimer(which)\n\nReturns current value of given itimer.'
p162
sg3
I01
sg7
I2
sg8
S'getitimer'
p163
sa(dp164
g1
S'getsignal(sig) -> action\n\nReturn the current action for the given signal.  The return value can be:\nSIG_IGN -- if the signal is being ignored\nSIG_DFL -- if the default action for the signal is in effect\nNone -- if an unknown handler is in effect\nanything else -- the callable Python object used as a handler'
p165
sg3
I01
sg7
I2
sg8
S'getsignal'
p166
sa(dp167
g1
S'pause()\n\nWait until a signal arrives.'
p168
sg3
I01
sg7
I2
sg8
S'pause'
p169
sa(dp170
g1
S"set_wakeup_fd(fd) -> fd\n\nSets the fd to be written to (with '\\0') when a signal\ncomes in.  A library can use this to wakeup select or poll.\nThe previous fd is returned.\n\nThe fd must be non-blocking."
p171
sg3
I01
sg7
I2
sg8
S'set_wakeup_fd'
p172
sa(dp173
g1
S'setitimer(which, seconds[, interval])\n\nSets given itimer (one of ITIMER_REAL, ITIMER_VIRTUAL\nor ITIMER_PROF) to fire after value seconds and after\nthat every interval seconds.\nThe itimer can be cleared by setting seconds to zero.\n\nReturns old values as a tuple: (delay, interval).'
p174
sg3
I01
sg7
I2
sg8
S'setitimer'
p175
sa(dp176
g1
S'siginterrupt(sig, flag) -> None\nchange system call restart behaviour: if flag is False, system calls\nwill be restarted when interrupted by signal sig, else system calls\nwill be interrupted.'
p177
sg3
I01
sg7
I2
sg8
S'siginterrupt'
p178
sa(dp179
g1
S'signal(sig, action) -> action\n\nSet the action for the given signal.  The action can be SIG_DFL,\nSIG_IGN, or a callable Python object.  The previous action is\nreturned.  See getsignal() for possible return values.\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.'
p180
sg3
I01
sg7
I2
sg8
S'signal'
p181
sasg8
S'signal'
p182
s.