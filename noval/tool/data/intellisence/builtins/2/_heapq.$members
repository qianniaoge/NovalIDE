(dp0
S'doc'
p1
S'Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!\n'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'__about__'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'__doc__'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'__name__'
p13
sa(dp14
g3
I01
sg7
I5
sg8
S'__package__'
p15
sa(dp16
g1
S'Transform list into a heap, in-place, in O(len(heap)) time.'
p17
sg3
I01
sg7
I2
sg8
S'heapify'
p18
sa(dp19
g1
S'Pop the smallest item off the heap, maintaining the heap invariant.'
p20
sg3
I01
sg7
I2
sg8
S'heappop'
p21
sa(dp22
g1
S'heappush(heap, item) -> None. Push item onto heap, maintaining the heap invariant.'
p23
sg3
I01
sg7
I2
sg8
S'heappush'
p24
sa(dp25
g1
S'heappushpop(heap, item) -> value. Push item on the heap, then pop and return the smallest item\nfrom the heap. The combined action runs more efficiently than\nheappush() followed by a separate call to heappop().'
p26
sg3
I01
sg7
I2
sg8
S'heappushpop'
p27
sa(dp28
g1
S'heapreplace(heap, item) -> value. Pop and return the current smallest value, and add the new item.\n\nThis is more efficient than heappop() followed by heappush(), and can be\nmore appropriate when using a fixed-size heap.  Note that the value\nreturned may be larger than item!  That constrains reasonable uses of\nthis routine unless written as part of a conditional replacement:\n\n    if item > heap[0]:\n        item = heapreplace(heap, item)\n'
p29
sg3
I01
sg7
I2
sg8
S'heapreplace'
p30
sa(dp31
g1
S'Find the n largest elements in a dataset.\n\nEquivalent to:  sorted(iterable, reverse=True)[:n]\n'
p32
sg3
I01
sg7
I2
sg8
S'nlargest'
p33
sa(dp34
g1
S'Find the n smallest elements in a dataset.\n\nEquivalent to:  sorted(iterable)[:n]\n'
p35
sg3
I01
sg7
I2
sg8
S'nsmallest'
p36
sasg8
S'_heapq'
p37
s.