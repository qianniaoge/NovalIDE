(dp0
S'doc'
p1
S'This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.'
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g3
I01
sS'type'
p7
I5
sS'name'
p8
S'EX_CANTCREAT'
p9
sa(dp10
g3
I01
sg7
I5
sg8
S'EX_CONFIG'
p11
sa(dp12
g3
I01
sg7
I5
sg8
S'EX_DATAERR'
p13
sa(dp14
g3
I01
sg7
I5
sg8
S'EX_IOERR'
p15
sa(dp16
g3
I01
sg7
I5
sg8
S'EX_NOHOST'
p17
sa(dp18
g3
I01
sg7
I5
sg8
S'EX_NOINPUT'
p19
sa(dp20
g3
I01
sg7
I5
sg8
S'EX_NOPERM'
p21
sa(dp22
g3
I01
sg7
I5
sg8
S'EX_NOUSER'
p23
sa(dp24
g3
I01
sg7
I5
sg8
S'EX_OK'
p25
sa(dp26
g3
I01
sg7
I5
sg8
S'EX_OSERR'
p27
sa(dp28
g3
I01
sg7
I5
sg8
S'EX_OSFILE'
p29
sa(dp30
g3
I01
sg7
I5
sg8
S'EX_PROTOCOL'
p31
sa(dp32
g3
I01
sg7
I5
sg8
S'EX_SOFTWARE'
p33
sa(dp34
g3
I01
sg7
I5
sg8
S'EX_TEMPFAIL'
p35
sa(dp36
g3
I01
sg7
I5
sg8
S'EX_UNAVAILABLE'
p37
sa(dp38
g3
I01
sg7
I5
sg8
S'EX_USAGE'
p39
sa(dp40
g3
I01
sg7
I5
sg8
S'F_OK'
p41
sa(dp42
g3
I01
sg7
I5
sg8
S'NGROUPS_MAX'
p43
sa(dp44
g3
I01
sg7
I5
sg8
S'O_APPEND'
p45
sa(dp46
g3
I01
sg7
I5
sg8
S'O_ASYNC'
p47
sa(dp48
g3
I01
sg7
I5
sg8
S'O_CREAT'
p49
sa(dp50
g3
I01
sg7
I5
sg8
S'O_DIRECT'
p51
sa(dp52
g3
I01
sg7
I5
sg8
S'O_DIRECTORY'
p53
sa(dp54
g3
I01
sg7
I5
sg8
S'O_DSYNC'
p55
sa(dp56
g3
I01
sg7
I5
sg8
S'O_EXCL'
p57
sa(dp58
g3
I01
sg7
I5
sg8
S'O_LARGEFILE'
p59
sa(dp60
g3
I01
sg7
I5
sg8
S'O_NDELAY'
p61
sa(dp62
g3
I01
sg7
I5
sg8
S'O_NOATIME'
p63
sa(dp64
g3
I01
sg7
I5
sg8
S'O_NOCTTY'
p65
sa(dp66
g3
I01
sg7
I5
sg8
S'O_NOFOLLOW'
p67
sa(dp68
g3
I01
sg7
I5
sg8
S'O_NONBLOCK'
p69
sa(dp70
g3
I01
sg7
I5
sg8
S'O_RDONLY'
p71
sa(dp72
g3
I01
sg7
I5
sg8
S'O_RDWR'
p73
sa(dp74
g3
I01
sg7
I5
sg8
S'O_RSYNC'
p75
sa(dp76
g3
I01
sg7
I5
sg8
S'O_SYNC'
p77
sa(dp78
g3
I01
sg7
I5
sg8
S'O_TRUNC'
p79
sa(dp80
g3
I01
sg7
I5
sg8
S'O_WRONLY'
p81
sa(dp82
g3
I01
sg7
I5
sg8
S'R_OK'
p83
sa(dp84
g3
I01
sg7
I5
sg8
S'ST_APPEND'
p85
sa(dp86
g3
I01
sg7
I5
sg8
S'ST_MANDLOCK'
p87
sa(dp88
g3
I01
sg7
I5
sg8
S'ST_NOATIME'
p89
sa(dp90
g3
I01
sg7
I5
sg8
S'ST_NODEV'
p91
sa(dp92
g3
I01
sg7
I5
sg8
S'ST_NODIRATIME'
p93
sa(dp94
g3
I01
sg7
I5
sg8
S'ST_NOEXEC'
p95
sa(dp96
g3
I01
sg7
I5
sg8
S'ST_NOSUID'
p97
sa(dp98
g3
I01
sg7
I5
sg8
S'ST_RDONLY'
p99
sa(dp100
g3
I01
sg7
I5
sg8
S'ST_RELATIME'
p101
sa(dp102
g3
I01
sg7
I5
sg8
S'ST_SYNCHRONOUS'
p103
sa(dp104
g3
I01
sg7
I5
sg8
S'ST_WRITE'
p105
sa(dp106
g3
I01
sg7
I5
sg8
S'TMP_MAX'
p107
sa(dp108
g3
I01
sg7
I5
sg8
S'WCONTINUED'
p109
sa(dp110
g1
S"WCOREDUMP(status) -> bool\n\nReturn True if the process returning 'status' was dumped to a core file."
p111
sg3
I01
sg7
I2
sg8
S'WCOREDUMP'
p112
sa(dp113
g1
S"WEXITSTATUS(status) -> integer\n\nReturn the process return code from 'status'."
p114
sg3
I01
sg7
I2
sg8
S'WEXITSTATUS'
p115
sa(dp116
g1
S"WIFCONTINUED(status) -> bool\n\nReturn True if the process returning 'status' was continued from a\njob control stop."
p117
sg3
I01
sg7
I2
sg8
S'WIFCONTINUED'
p118
sa(dp119
g1
S"WIFEXITED(status) -> bool\n\nReturn true if the process returning 'status' exited using the exit()\nsystem call."
p120
sg3
I01
sg7
I2
sg8
S'WIFEXITED'
p121
sa(dp122
g1
S"WIFSIGNALED(status) -> bool\n\nReturn True if the process returning 'status' was terminated by a signal."
p123
sg3
I01
sg7
I2
sg8
S'WIFSIGNALED'
p124
sa(dp125
g1
S"WIFSTOPPED(status) -> bool\n\nReturn True if the process returning 'status' was stopped."
p126
sg3
I01
sg7
I2
sg8
S'WIFSTOPPED'
p127
sa(dp128
g3
I01
sg7
I5
sg8
S'WNOHANG'
p129
sa(dp130
g1
S"WSTOPSIG(status) -> integer\n\nReturn the signal that stopped the process that provided\nthe 'status' value."
p131
sg3
I01
sg7
I2
sg8
S'WSTOPSIG'
p132
sa(dp133
g1
S"WTERMSIG(status) -> integer\n\nReturn the signal that terminated the process that provided the 'status'\nvalue."
p134
sg3
I01
sg7
I2
sg8
S'WTERMSIG'
p135
sa(dp136
g3
I01
sg7
I5
sg8
S'WUNTRACED'
p137
sa(dp138
g3
I01
sg7
I5
sg8
S'W_OK'
p139
sa(dp140
g3
I01
sg7
I5
sg8
S'X_OK'
p141
sa(dp142
g3
I01
sg7
I5
sg8
S'__doc__'
p143
sa(dp144
g3
I01
sg7
I5
sg8
S'__name__'
p145
sa(dp146
g3
I01
sg7
I5
sg8
S'__package__'
p147
sa(dp148
g1
S'_exit(status)\n\nExit to the system with specified status, without normal exit processing.'
p149
sg3
I01
sg7
I2
sg8
S'_exit'
p150
sa(dp151
g1
S"abort() -> does not return!\n\nAbort the interpreter immediately.  This 'dumps core' or otherwise fails\nin the hardest way possible on the hosting operating system."
p152
sg3
I01
sg7
I2
sg8
S'abort'
p153
sa(dp154
g1
S'access(path, mode) -> True if granted, False otherwise\n\nUse the real uid/gid to test for access to a path.  Note that most\noperations will use the effective uid/gid, therefore this routine can\nbe used in a suid/sgid environment to test if the invoking user has the\nspecified access to the path.  The mode argument can be F_OK to test\nexistence, or the inclusive-OR of R_OK, W_OK, and X_OK.'
p155
sg3
I01
sg7
I2
sg8
S'access'
p156
sa(dp157
g1
S'chdir(path)\n\nChange the current working directory to the specified path.'
p158
sg3
I01
sg7
I2
sg8
S'chdir'
p159
sa(dp160
g1
S'chmod(path, mode)\n\nChange the access permissions of a file.'
p161
sg3
I01
sg7
I2
sg8
S'chmod'
p162
sa(dp163
g1
S'chown(path, uid, gid)\n\nChange the owner and group id of path to the numeric uid and gid.'
p164
sg3
I01
sg7
I2
sg8
S'chown'
p165
sa(dp166
g1
S'chroot(path)\n\nChange root directory to path.'
p167
sg3
I01
sg7
I2
sg8
S'chroot'
p168
sa(dp169
g1
S'close(fd)\n\nClose a file descriptor (for low level IO).'
p170
sg3
I01
sg7
I2
sg8
S'close'
p171
sa(dp172
g1
S'closerange(fd_low, fd_high)\n\nCloses all file descriptors in [fd_low, fd_high), ignoring errors.'
p173
sg3
I01
sg7
I2
sg8
S'closerange'
p174
sa(dp175
g1
S'confstr(name) -> string\n\nReturn a string-valued system configuration variable.'
p176
sg3
I01
sg7
I2
sg8
S'confstr'
p177
sa(dp178
g3
I01
sg7
I5
sg8
S'confstr_names'
p179
sa(dp180
g1
S'ctermid() -> string\n\nReturn the name of the controlling terminal for this process.'
p181
sg3
I01
sg7
I2
sg8
S'ctermid'
p182
sa(dp183
g1
S'dup(fd) -> fd2\n\nReturn a duplicate of a file descriptor.'
p184
sg3
I01
sg7
I2
sg8
S'dup'
p185
sa(dp186
g1
S'dup2(old_fd, new_fd)\n\nDuplicate file descriptor.'
p187
sg3
I01
sg7
I2
sg8
S'dup2'
p188
sa(dp189
g3
I01
sg7
I5
sg8
S'environ'
p190
sa(dp191
g1
S'OS system call failed.'
p192
sg3
I01
sg4
(lp193
(dp194
g3
I01
sg7
I5
sg8
S'__delattr__'
p195
sa(dp196
g3
I01
sg7
I5
sg8
S'__dict__'
p197
sa(dp198
g3
I01
sg7
I5
sg8
g143
sa(dp199
g1
S'default object formatter'
p200
sg3
I01
sg7
I2
sg8
S'__format__'
p201
sa(dp202
g3
I01
sg7
I5
sg8
S'__getattribute__'
p203
sa(dp204
g3
I01
sg7
I5
sg8
S'__getitem__'
p205
sa(dp206
g3
I01
sg7
I5
sg8
S'__getslice__'
p207
sa(dp208
g3
I01
sg7
I5
sg8
S'__hash__'
p209
sa(dp210
g3
I01
sg7
I5
sg8
S'__init__'
p211
sa(dp212
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p213
sg3
I01
sg7
I2
sg8
S'__new__'
p214
sa(dp215
g1
Nsg3
I01
sg7
I2
sg8
S'__reduce__'
p216
sa(dp217
g1
S'helper for pickle'
p218
sg3
I01
sg7
I2
sg8
S'__reduce_ex__'
p219
sa(dp220
g3
I01
sg7
I5
sg8
S'__repr__'
p221
sa(dp222
g3
I01
sg7
I5
sg8
S'__setattr__'
p223
sa(dp224
g1
Nsg3
I01
sg7
I2
sg8
S'__setstate__'
p225
sa(dp226
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p227
sg3
I01
sg7
I2
sg8
S'__sizeof__'
p228
sa(dp229
g3
I01
sg7
I5
sg8
S'__str__'
p230
sa(dp231
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p232
sg3
I01
sg7
I2
sg8
S'__subclasshook__'
p233
sa(dp234
g1
Nsg3
I01
sg7
I2
sg8
S'__unicode__'
p235
sa(dp236
g3
I01
sg7
I5
sg8
S'args'
p237
sa(dp238
g3
I01
sg7
I5
sg8
S'errno'
p239
sa(dp240
g3
I01
sg7
I5
sg8
S'filename'
p241
sa(dp242
g3
I01
sg7
I5
sg8
S'message'
p243
sa(dp244
g3
I01
sg7
I5
sg8
S'strerror'
p245
sasg7
I3
sg8
S'error'
p246
sa(dp247
g1
S'execv(path, args)\n\nExecute an executable path with arguments, replacing current process.\n\n    path: path of executable file\n    args: tuple or list of strings'
p248
sg3
I01
sg7
I2
sg8
S'execv'
p249
sa(dp250
g1
S'execve(path, args, env)\n\nExecute a path with arguments and environment, replacing current process.\n\n    path: path of executable file\n    args: tuple or list of arguments\n    env: dictionary of strings mapping to strings'
p251
sg3
I01
sg7
I2
sg8
S'execve'
p252
sa(dp253
g1
S'fchdir(fildes)\n\nChange to the directory of the given file descriptor.  fildes must be\nopened on a directory, not a file.'
p254
sg3
I01
sg7
I2
sg8
S'fchdir'
p255
sa(dp256
g1
S'fchmod(fd, mode)\n\nChange the access permissions of the file given by file\ndescriptor fd.'
p257
sg3
I01
sg7
I2
sg8
S'fchmod'
p258
sa(dp259
g1
S'fchown(fd, uid, gid)\n\nChange the owner and group id of the file given by file descriptor\nfd to the numeric uid and gid.'
p260
sg3
I01
sg7
I2
sg8
S'fchown'
p261
sa(dp262
g1
S'fdatasync(fildes)\n\nforce write of file with filedescriptor to disk.\n does not force update of metadata.'
p263
sg3
I01
sg7
I2
sg8
S'fdatasync'
p264
sa(dp265
g1
S"fdopen(fd [, mode='r' [, bufsize]]) -> file_object\n\nReturn an open file object connected to a file descriptor."
p266
sg3
I01
sg7
I2
sg8
S'fdopen'
p267
sa(dp268
g1
S'fork() -> pid\n\nFork a child process.\nReturn 0 to child process and PID of child to parent process.'
p269
sg3
I01
sg7
I2
sg8
S'fork'
p270
sa(dp271
g1
S'forkpty() -> (pid, master_fd)\n\nFork a new process with a new pseudo-terminal as controlling tty.\n\nLike fork(), return 0 as pid to child process, and PID of child to parent.\nTo both, return fd of newly opened pseudo-terminal.\n'
p272
sg3
I01
sg7
I2
sg8
S'forkpty'
p273
sa(dp274
g1
S'fpathconf(fd, name) -> integer\n\nReturn the configuration limit name for the file descriptor fd.\nIf there is no limit, return -1.'
p275
sg3
I01
sg7
I2
sg8
S'fpathconf'
p276
sa(dp277
g1
S'fstat(fd) -> stat result\n\nLike stat(), but for an open file descriptor.'
p278
sg3
I01
sg7
I2
sg8
S'fstat'
p279
sa(dp280
g1
S'fstatvfs(fd) -> statvfs result\n\nPerform an fstatvfs system call on the given fd.'
p281
sg3
I01
sg7
I2
sg8
S'fstatvfs'
p282
sa(dp283
g1
S'fsync(fildes)\n\nforce write of file with filedescriptor to disk.'
p284
sg3
I01
sg7
I2
sg8
S'fsync'
p285
sa(dp286
g1
S'ftruncate(fd, length)\n\nTruncate a file to a specified length.'
p287
sg3
I01
sg7
I2
sg8
S'ftruncate'
p288
sa(dp289
g1
S'getcwd() -> path\n\nReturn a string representing the current working directory.'
p290
sg3
I01
sg7
I2
sg8
S'getcwd'
p291
sa(dp292
g1
S'getcwdu() -> path\n\nReturn a unicode string representing the current working directory.'
p293
sg3
I01
sg7
I2
sg8
S'getcwdu'
p294
sa(dp295
g1
S"getegid() -> egid\n\nReturn the current process's effective group id."
p296
sg3
I01
sg7
I2
sg8
S'getegid'
p297
sa(dp298
g1
S"geteuid() -> euid\n\nReturn the current process's effective user id."
p299
sg3
I01
sg7
I2
sg8
S'geteuid'
p300
sa(dp301
g1
S"getgid() -> gid\n\nReturn the current process's group id."
p302
sg3
I01
sg7
I2
sg8
S'getgid'
p303
sa(dp304
g1
S'getgroups() -> list of group IDs\n\nReturn list of supplemental group IDs for the process.'
p305
sg3
I01
sg7
I2
sg8
S'getgroups'
p306
sa(dp307
g1
S'getloadavg() -> (float, float, float)\n\nReturn the number of processes in the system run queue averaged over\nthe last 1, 5, and 15 minutes or raises OSError if the load average\nwas unobtainable'
p308
sg3
I01
sg7
I2
sg8
S'getloadavg'
p309
sa(dp310
g1
S'getlogin() -> string\n\nReturn the actual login name.'
p311
sg3
I01
sg7
I2
sg8
S'getlogin'
p312
sa(dp313
g1
S'getpgid(pid) -> pgid\n\nCall the system call getpgid().'
p314
sg3
I01
sg7
I2
sg8
S'getpgid'
p315
sa(dp316
g1
S'getpgrp() -> pgrp\n\nReturn the current process group id.'
p317
sg3
I01
sg7
I2
sg8
S'getpgrp'
p318
sa(dp319
g1
S'getpid() -> pid\n\nReturn the current process id'
p320
sg3
I01
sg7
I2
sg8
S'getpid'
p321
sa(dp322
g1
S"getppid() -> ppid\n\nReturn the parent's process id."
p323
sg3
I01
sg7
I2
sg8
S'getppid'
p324
sa(dp325
g1
S"getresgid() -> (rgid, egid, sgid)\n\nGet tuple of the current process's real, effective, and saved group ids."
p326
sg3
I01
sg7
I2
sg8
S'getresgid'
p327
sa(dp328
g1
S"getresuid() -> (ruid, euid, suid)\n\nGet tuple of the current process's real, effective, and saved user ids."
p329
sg3
I01
sg7
I2
sg8
S'getresuid'
p330
sa(dp331
g1
S'getsid(pid) -> sid\n\nCall the system call getsid().'
p332
sg3
I01
sg7
I2
sg8
S'getsid'
p333
sa(dp334
g1
S"getuid() -> uid\n\nReturn the current process's user id."
p335
sg3
I01
sg7
I2
sg8
S'getuid'
p336
sa(dp337
g1
S'initgroups(username, gid) -> None\n\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.'
p338
sg3
I01
sg7
I2
sg8
S'initgroups'
p339
sa(dp340
g1
S"isatty(fd) -> bool\n\nReturn True if the file descriptor 'fd' is an open file descriptor\nconnected to the slave end of a terminal."
p341
sg3
I01
sg7
I2
sg8
S'isatty'
p342
sa(dp343
g1
S'kill(pid, sig)\n\nKill a process with a signal.'
p344
sg3
I01
sg7
I2
sg8
S'kill'
p345
sa(dp346
g1
S'killpg(pgid, sig)\n\nKill a process group with a signal.'
p347
sg3
I01
sg7
I2
sg8
S'killpg'
p348
sa(dp349
g1
S'lchown(path, uid, gid)\n\nChange the owner and group id of path to the numeric uid and gid.\nThis function will not follow symbolic links.'
p350
sg3
I01
sg7
I2
sg8
S'lchown'
p351
sa(dp352
g1
S'link(src, dst)\n\nCreate a hard link to a file.'
p353
sg3
I01
sg7
I2
sg8
S'link'
p354
sa(dp355
g1
S"listdir(path) -> list_of_strings\n\nReturn a list containing the names of the entries in the directory.\n\n    path: path of directory to list\n\nThe list is in arbitrary order.  It does not include the special\nentries '.' and '..' even if they are present in the directory."
p356
sg3
I01
sg7
I2
sg8
S'listdir'
p357
sa(dp358
g1
S'lseek(fd, pos, how) -> newpos\n\nSet the current position of a file descriptor.\nReturn the new cursor position in bytes, starting from the beginning.'
p359
sg3
I01
sg7
I2
sg8
S'lseek'
p360
sa(dp361
g1
S'lstat(path) -> stat result\n\nLike stat(path), but do not follow symbolic links.'
p362
sg3
I01
sg7
I2
sg8
S'lstat'
p363
sa(dp364
g1
S'major(device) -> major number\nExtracts a device major number from a raw device number.'
p365
sg3
I01
sg7
I2
sg8
S'major'
p366
sa(dp367
g1
S'makedev(major, minor) -> device number\nComposes a raw device number from the major and minor device numbers.'
p368
sg3
I01
sg7
I2
sg8
S'makedev'
p369
sa(dp370
g1
S'minor(device) -> minor number\nExtracts a device minor number from a raw device number.'
p371
sg3
I01
sg7
I2
sg8
S'minor'
p372
sa(dp373
g1
S'mkdir(path [, mode=0777])\n\nCreate a directory.'
p374
sg3
I01
sg7
I2
sg8
S'mkdir'
p375
sa(dp376
g1
S'mkfifo(filename [, mode=0666])\n\nCreate a FIFO (a POSIX named pipe).'
p377
sg3
I01
sg7
I2
sg8
S'mkfifo'
p378
sa(dp379
g1
S'mknod(filename [, mode=0600, device])\n\nCreate a filesystem node (file, device special file or named pipe)\nnamed filename. mode specifies both the permissions to use and the\ntype of node to be created, being combined (bitwise OR) with one of\nS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO. For S_IFCHR and S_IFBLK,\ndevice defines the newly created device special file (probably using\nos.makedev()), otherwise it is ignored.'
p380
sg3
I01
sg7
I2
sg8
S'mknod'
p381
sa(dp382
g1
S'nice(inc) -> new_priority\n\nDecrease the priority of process by inc and return the new priority.'
p383
sg3
I01
sg7
I2
sg8
S'nice'
p384
sa(dp385
g1
S'open(filename, flag [, mode=0777]) -> fd\n\nOpen a file (for low level IO).'
p386
sg3
I01
sg7
I2
sg8
S'open'
p387
sa(dp388
g1
S"openpty() -> (master_fd, slave_fd)\n\nOpen a pseudo-terminal, returning open fd's for both master and slave end.\n"
p389
sg3
I01
sg7
I2
sg8
S'openpty'
p390
sa(dp391
g1
S'pathconf(path, name) -> integer\n\nReturn the configuration limit name for the file or directory path.\nIf there is no limit, return -1.'
p392
sg3
I01
sg7
I2
sg8
S'pathconf'
p393
sa(dp394
g3
I01
sg7
I5
sg8
S'pathconf_names'
p395
sa(dp396
g1
S'pipe() -> (read_end, write_end)\n\nCreate a pipe.'
p397
sg3
I01
sg7
I2
sg8
S'pipe'
p398
sa(dp399
g1
S"popen(command [, mode='r' [, bufsize]]) -> pipe\n\nOpen a pipe to/from a command returning a file object."
p400
sg3
I01
sg7
I2
sg8
S'popen'
p401
sa(dp402
g1
S'putenv(key, value)\n\nChange or add an environment variable.'
p403
sg3
I01
sg7
I2
sg8
S'putenv'
p404
sa(dp405
g1
S'read(fd, buffersize) -> string\n\nRead a file descriptor.'
p406
sg3
I01
sg7
I2
sg8
S'read'
p407
sa(dp408
g1
S'readlink(path) -> path\n\nReturn a string representing the path to which the symbolic link points.'
p409
sg3
I01
sg7
I2
sg8
S'readlink'
p410
sa(dp411
g1
S'remove(path)\n\nRemove a file (same as unlink(path)).'
p412
sg3
I01
sg7
I2
sg8
S'remove'
p413
sa(dp414
g1
S'rename(old, new)\n\nRename a file or directory.'
p415
sg3
I01
sg7
I2
sg8
S'rename'
p416
sa(dp417
g1
S'rmdir(path)\n\nRemove a directory.'
p418
sg3
I01
sg7
I2
sg8
S'rmdir'
p419
sa(dp420
g1
S"setegid(gid)\n\nSet the current process's effective group id."
p421
sg3
I01
sg7
I2
sg8
S'setegid'
p422
sa(dp423
g1
S"seteuid(uid)\n\nSet the current process's effective user id."
p424
sg3
I01
sg7
I2
sg8
S'seteuid'
p425
sa(dp426
g1
S"setgid(gid)\n\nSet the current process's group id."
p427
sg3
I01
sg7
I2
sg8
S'setgid'
p428
sa(dp429
g1
S'setgroups(list)\n\nSet the groups of the current process to list.'
p430
sg3
I01
sg7
I2
sg8
S'setgroups'
p431
sa(dp432
g1
S'setpgid(pid, pgrp)\n\nCall the system call setpgid().'
p433
sg3
I01
sg7
I2
sg8
S'setpgid'
p434
sa(dp435
g1
S'setpgrp()\n\nMake this process the process group leader.'
p436
sg3
I01
sg7
I2
sg8
S'setpgrp'
p437
sa(dp438
g1
S"setregid(rgid, egid)\n\nSet the current process's real and effective group ids."
p439
sg3
I01
sg7
I2
sg8
S'setregid'
p440
sa(dp441
g1
S"setresgid(rgid, egid, sgid)\n\nSet the current process's real, effective, and saved group ids."
p442
sg3
I01
sg7
I2
sg8
S'setresgid'
p443
sa(dp444
g1
S"setresuid(ruid, euid, suid)\n\nSet the current process's real, effective, and saved user ids."
p445
sg3
I01
sg7
I2
sg8
S'setresuid'
p446
sa(dp447
g1
S"setreuid(ruid, euid)\n\nSet the current process's real and effective user ids."
p448
sg3
I01
sg7
I2
sg8
S'setreuid'
p449
sa(dp450
g1
S'setsid()\n\nCall the system call setsid().'
p451
sg3
I01
sg7
I2
sg8
S'setsid'
p452
sa(dp453
g1
S"setuid(uid)\n\nSet the current process's user id."
p454
sg3
I01
sg7
I2
sg8
S'setuid'
p455
sa(dp456
g1
S'stat(path) -> stat result\n\nPerform a stat system call on the given path.'
p457
sg3
I01
sg7
I2
sg8
S'stat'
p458
sa(dp459
g1
S'stat_float_times([newval]) -> oldval\n\nDetermine whether os.[lf]stat represents time stamps as float objects.\nIf newval is True, future calls to stat() return floats, if it is False,\nfuture calls return ints. \nIf newval is omitted, return the current setting.\n'
p460
sg3
I01
sg7
I2
sg8
S'stat_float_times'
p461
sa(dp462
g1
S'stat_result: Result from stat or lstat.\n\nThis object may be accessed either as a tuple of\n  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\nor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\nPosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\nor st_flags, they are available as attributes only.\n\nSee os.stat for more information.'
p463
sg3
I01
sg4
(lp464
(dp465
g3
I01
sg7
I5
sg8
S'__add__'
p466
sa(dp467
g3
I01
sg7
I5
sg8
S'__contains__'
p468
sa(dp469
g3
I01
sg7
I5
sg8
g195
sa(dp470
g3
I01
sg7
I5
sg8
g143
sa(dp471
g3
I01
sg7
I5
sg8
S'__eq__'
p472
sa(dp473
g1
S'default object formatter'
p474
sg3
I01
sg7
I2
sg8
g201
sa(dp475
g3
I01
sg7
I5
sg8
S'__ge__'
p476
sa(dp477
g3
I01
sg7
I5
sg8
g203
sa(dp478
g3
I01
sg7
I5
sg8
g205
sa(dp479
g3
I01
sg7
I5
sg8
g207
sa(dp480
g3
I01
sg7
I5
sg8
S'__gt__'
p481
sa(dp482
g3
I01
sg7
I5
sg8
g209
sa(dp483
g3
I01
sg7
I5
sg8
g211
sa(dp484
g3
I01
sg7
I5
sg8
S'__le__'
p485
sa(dp486
g3
I01
sg7
I5
sg8
S'__len__'
p487
sa(dp488
g3
I01
sg7
I5
sg8
S'__lt__'
p489
sa(dp490
g3
I01
sg7
I5
sg8
S'__mul__'
p491
sa(dp492
g3
I01
sg7
I5
sg8
S'__ne__'
p493
sa(dp494
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p495
sg3
I01
sg7
I2
sg8
g214
sa(dp496
g1
Nsg3
I01
sg7
I2
sg8
g216
sa(dp497
g1
S'helper for pickle'
p498
sg3
I01
sg7
I2
sg8
g219
sa(dp499
g3
I01
sg7
I5
sg8
g221
sa(dp500
g3
I01
sg7
I5
sg8
S'__rmul__'
p501
sa(dp502
g3
I01
sg7
I5
sg8
g223
sa(dp503
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p504
sg3
I01
sg7
I2
sg8
g228
sa(dp505
g3
I01
sg7
I5
sg8
g230
sa(dp506
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p507
sg3
I01
sg7
I2
sg8
g233
sa(dp508
g3
I01
sg7
I5
sg8
S'n_fields'
p509
sa(dp510
g3
I01
sg7
I5
sg8
S'n_sequence_fields'
p511
sa(dp512
g3
I01
sg7
I5
sg8
S'n_unnamed_fields'
p513
sa(dp514
g3
I01
sg7
I5
sg8
S'st_atime'
p515
sa(dp516
g3
I01
sg7
I5
sg8
S'st_blksize'
p517
sa(dp518
g3
I01
sg7
I5
sg8
S'st_blocks'
p519
sa(dp520
g3
I01
sg7
I5
sg8
S'st_ctime'
p521
sa(dp522
g3
I01
sg7
I5
sg8
S'st_dev'
p523
sa(dp524
g3
I01
sg7
I5
sg8
S'st_gid'
p525
sa(dp526
g3
I01
sg7
I5
sg8
S'st_ino'
p527
sa(dp528
g3
I01
sg7
I5
sg8
S'st_mode'
p529
sa(dp530
g3
I01
sg7
I5
sg8
S'st_mtime'
p531
sa(dp532
g3
I01
sg7
I5
sg8
S'st_nlink'
p533
sa(dp534
g3
I01
sg7
I5
sg8
S'st_rdev'
p535
sa(dp536
g3
I01
sg7
I5
sg8
S'st_size'
p537
sa(dp538
g3
I01
sg7
I5
sg8
S'st_uid'
p539
sasg7
I3
sg8
S'stat_result'
p540
sa(dp541
g1
S'statvfs(path) -> statvfs result\n\nPerform a statvfs system call on the given path.'
p542
sg3
I01
sg7
I2
sg8
S'statvfs'
p543
sa(dp544
g1
S'statvfs_result: Result from statvfs or fstatvfs.\n\nThis object may be accessed either as a tuple of\n  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\nor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\nSee os.statvfs for more information.'
p545
sg3
I01
sg4
(lp546
(dp547
g3
I01
sg7
I5
sg8
g466
sa(dp548
g3
I01
sg7
I5
sg8
g468
sa(dp549
g3
I01
sg7
I5
sg8
g195
sa(dp550
g3
I01
sg7
I5
sg8
g143
sa(dp551
g3
I01
sg7
I5
sg8
g472
sa(dp552
g1
S'default object formatter'
p553
sg3
I01
sg7
I2
sg8
g201
sa(dp554
g3
I01
sg7
I5
sg8
g476
sa(dp555
g3
I01
sg7
I5
sg8
g203
sa(dp556
g3
I01
sg7
I5
sg8
g205
sa(dp557
g3
I01
sg7
I5
sg8
g207
sa(dp558
g3
I01
sg7
I5
sg8
g481
sa(dp559
g3
I01
sg7
I5
sg8
g209
sa(dp560
g3
I01
sg7
I5
sg8
g211
sa(dp561
g3
I01
sg7
I5
sg8
g485
sa(dp562
g3
I01
sg7
I5
sg8
g487
sa(dp563
g3
I01
sg7
I5
sg8
g489
sa(dp564
g3
I01
sg7
I5
sg8
g491
sa(dp565
g3
I01
sg7
I5
sg8
g493
sa(dp566
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p567
sg3
I01
sg7
I2
sg8
g214
sa(dp568
g1
Nsg3
I01
sg7
I2
sg8
g216
sa(dp569
g1
S'helper for pickle'
p570
sg3
I01
sg7
I2
sg8
g219
sa(dp571
g3
I01
sg7
I5
sg8
g221
sa(dp572
g3
I01
sg7
I5
sg8
g501
sa(dp573
g3
I01
sg7
I5
sg8
g223
sa(dp574
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p575
sg3
I01
sg7
I2
sg8
g228
sa(dp576
g3
I01
sg7
I5
sg8
g230
sa(dp577
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p578
sg3
I01
sg7
I2
sg8
g233
sa(dp579
g3
I01
sg7
I5
sg8
S'f_bavail'
p580
sa(dp581
g3
I01
sg7
I5
sg8
S'f_bfree'
p582
sa(dp583
g3
I01
sg7
I5
sg8
S'f_blocks'
p584
sa(dp585
g3
I01
sg7
I5
sg8
S'f_bsize'
p586
sa(dp587
g3
I01
sg7
I5
sg8
S'f_favail'
p588
sa(dp589
g3
I01
sg7
I5
sg8
S'f_ffree'
p590
sa(dp591
g3
I01
sg7
I5
sg8
S'f_files'
p592
sa(dp593
g3
I01
sg7
I5
sg8
S'f_flag'
p594
sa(dp595
g3
I01
sg7
I5
sg8
S'f_frsize'
p596
sa(dp597
g3
I01
sg7
I5
sg8
S'f_namemax'
p598
sa(dp599
g3
I01
sg7
I5
sg8
g509
sa(dp600
g3
I01
sg7
I5
sg8
g511
sa(dp601
g3
I01
sg7
I5
sg8
g513
sasg7
I3
sg8
S'statvfs_result'
p602
sa(dp603
g1
S'strerror(code) -> string\n\nTranslate an error code to a message string.'
p604
sg3
I01
sg7
I2
sg8
g245
sa(dp605
g1
S'symlink(src, dst)\n\nCreate a symbolic link pointing to src named dst.'
p606
sg3
I01
sg7
I2
sg8
S'symlink'
p607
sa(dp608
g1
S'sysconf(name) -> integer\n\nReturn an integer-valued system configuration variable.'
p609
sg3
I01
sg7
I2
sg8
S'sysconf'
p610
sa(dp611
g3
I01
sg7
I5
sg8
S'sysconf_names'
p612
sa(dp613
g1
S'system(command) -> exit_status\n\nExecute the command (a string) in a subshell.'
p614
sg3
I01
sg7
I2
sg8
S'system'
p615
sa(dp616
g1
S'tcgetpgrp(fd) -> pgid\n\nReturn the process group associated with the terminal given by a fd.'
p617
sg3
I01
sg7
I2
sg8
S'tcgetpgrp'
p618
sa(dp619
g1
S'tcsetpgrp(fd, pgid)\n\nSet the process group associated with the terminal given by a fd.'
p620
sg3
I01
sg7
I2
sg8
S'tcsetpgrp'
p621
sa(dp622
g1
S'tempnam([dir[, prefix]]) -> string\n\nReturn a unique name for a temporary file.\nThe directory and a prefix may be specified as strings; they may be omitted\nor None if not needed.'
p623
sg3
I01
sg7
I2
sg8
S'tempnam'
p624
sa(dp625
g1
S'times() -> (utime, stime, cutime, cstime, elapsed_time)\n\nReturn a tuple of floating point numbers indicating process times.'
p626
sg3
I01
sg7
I2
sg8
S'times'
p627
sa(dp628
g1
S'tmpfile() -> file object\n\nCreate a temporary file with no directory entries.'
p629
sg3
I01
sg7
I2
sg8
S'tmpfile'
p630
sa(dp631
g1
S'tmpnam() -> string\n\nReturn a unique name for a temporary file.'
p632
sg3
I01
sg7
I2
sg8
S'tmpnam'
p633
sa(dp634
g1
S"ttyname(fd) -> string\n\nReturn the name of the terminal device connected to 'fd'."
p635
sg3
I01
sg7
I2
sg8
S'ttyname'
p636
sa(dp637
g1
S'umask(new_mask) -> old_mask\n\nSet the current numeric umask and return the previous umask.'
p638
sg3
I01
sg7
I2
sg8
S'umask'
p639
sa(dp640
g1
S'uname() -> (sysname, nodename, release, version, machine)\n\nReturn a tuple identifying the current operating system.'
p641
sg3
I01
sg7
I2
sg8
S'uname'
p642
sa(dp643
g1
S'unlink(path)\n\nRemove a file (same as remove(path)).'
p644
sg3
I01
sg7
I2
sg8
S'unlink'
p645
sa(dp646
g1
S'unsetenv(key)\n\nDelete an environment variable.'
p647
sg3
I01
sg7
I2
sg8
S'unsetenv'
p648
sa(dp649
g1
S'urandom(n) -> str\n\nReturn n random bytes suitable for cryptographic use.'
p650
sg3
I01
sg7
I2
sg8
S'urandom'
p651
sa(dp652
g1
S'utime(path, (atime, mtime))\nutime(path, None)\n\nSet the access and modified time of the file to the given values.  If the\nsecond form is used, set the access and modified times to the current time.'
p653
sg3
I01
sg7
I2
sg8
S'utime'
p654
sa(dp655
g1
S'wait() -> (pid, status)\n\nWait for completion of a child process.'
p656
sg3
I01
sg7
I2
sg8
S'wait'
p657
sa(dp658
g1
S'wait3(options) -> (pid, status, rusage)\n\nWait for completion of a child process.'
p659
sg3
I01
sg7
I2
sg8
S'wait3'
p660
sa(dp661
g1
S'wait4(pid, options) -> (pid, status, rusage)\n\nWait for completion of a given child process.'
p662
sg3
I01
sg7
I2
sg8
S'wait4'
p663
sa(dp664
g1
S'waitpid(pid, options) -> (pid, status)\n\nWait for completion of a given child process.'
p665
sg3
I01
sg7
I2
sg8
S'waitpid'
p666
sa(dp667
g1
S'write(fd, string) -> byteswritten\n\nWrite a string to a file descriptor.'
p668
sg3
I01
sg7
I2
sg8
S'write'
p669
sasg8
S'posix'
p670
s.