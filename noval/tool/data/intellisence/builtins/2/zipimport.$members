(dp0
S'doc'
p1
S"zipimport provides support for importing Python modules from Zip archives.\n\nThis module exports three objects:\n- zipimporter: a class; its constructor takes a path to a Zip archive.\n- ZipImportError: exception raised by zipimporter objects. It's a\n  subclass of ImportError, so it can be caught as ImportError, too.\n- _zip_directory_cache: a dict, mapping archive paths to zip directory\n  info dicts, as used in zipimporter._files.\n\nIt is usually not needed to use the zipimport module explicitly; it is\nused by the builtin import mechanism for sys.path items that are paths\nto Zip archives."
p2
sS'is_builtin'
p3
I01
sS'childs'
p4
(lp5
(dp6
g1
Nsg3
I01
sg4
(lp7
(dp8
g3
I01
sS'type'
p9
I5
sS'name'
p10
S'__delattr__'
p11
sa(dp12
g3
I01
sg9
I5
sg10
S'__dict__'
p13
sa(dp14
g3
I01
sg9
I5
sg10
S'__doc__'
p15
sa(dp16
g1
S'default object formatter'
p17
sg3
I01
sg9
I2
sg10
S'__format__'
p18
sa(dp19
g3
I01
sg9
I5
sg10
S'__getattribute__'
p20
sa(dp21
g3
I01
sg9
I5
sg10
S'__getitem__'
p22
sa(dp23
g3
I01
sg9
I5
sg10
S'__getslice__'
p24
sa(dp25
g3
I01
sg9
I5
sg10
S'__hash__'
p26
sa(dp27
g3
I01
sg9
I5
sg10
S'__init__'
p28
sa(dp29
g3
I01
sg9
I5
sg10
S'__module__'
p30
sa(dp31
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p32
sg3
I01
sg9
I2
sg10
S'__new__'
p33
sa(dp34
g1
Nsg3
I01
sg9
I2
sg10
S'__reduce__'
p35
sa(dp36
g1
S'helper for pickle'
p37
sg3
I01
sg9
I2
sg10
S'__reduce_ex__'
p38
sa(dp39
g3
I01
sg9
I5
sg10
S'__repr__'
p40
sa(dp41
g3
I01
sg9
I5
sg10
S'__setattr__'
p42
sa(dp43
g1
Nsg3
I01
sg9
I2
sg10
S'__setstate__'
p44
sa(dp45
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p46
sg3
I01
sg9
I2
sg10
S'__sizeof__'
p47
sa(dp48
g3
I01
sg9
I5
sg10
S'__str__'
p49
sa(dp50
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p51
sg3
I01
sg9
I2
sg10
S'__subclasshook__'
p52
sa(dp53
g1
Nsg3
I01
sg9
I2
sg10
S'__unicode__'
p54
sa(dp55
g3
I01
sg9
I5
sg10
S'__weakref__'
p56
sa(dp57
g3
I01
sg9
I5
sg10
S'args'
p58
sa(dp59
g3
I01
sg9
I5
sg10
S'message'
p60
sasg9
I3
sg10
S'ZipImportError'
p61
sa(dp62
g3
I01
sg9
I5
sg10
g15
sa(dp63
g3
I01
sg9
I5
sg10
S'__name__'
p64
sa(dp65
g3
I01
sg9
I5
sg10
S'__package__'
p66
sa(dp67
g3
I01
sg9
I5
sg10
S'_zip_directory_cache'
p68
sa(dp69
g1
S"zipimporter(archivepath) -> zipimporter object\n\nCreate a new zipimporter instance. 'archivepath' must be a path to\na zipfile, or to a specific path inside a zipfile. For example, it can be\n'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\nvalid directory inside the archive.\n\n'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\narchive.\n\nThe 'archive' attribute of zipimporter objects contains the name of the\nzipfile targeted."
p70
sg3
I01
sg4
(lp71
(dp72
g3
I01
sg9
I5
sg10
g11
sa(dp73
g3
I01
sg9
I5
sg10
g15
sa(dp74
g1
S'default object formatter'
p75
sg3
I01
sg9
I2
sg10
g18
sa(dp76
g3
I01
sg9
I5
sg10
g20
sa(dp77
g3
I01
sg9
I5
sg10
g26
sa(dp78
g3
I01
sg9
I5
sg10
g28
sa(dp79
g1
S'T.__new__(S, ...) -> a new object with type S, a subtype of T'
p80
sg3
I01
sg9
I2
sg10
g33
sa(dp81
g1
S'helper for pickle'
p82
sg3
I01
sg9
I2
sg10
g35
sa(dp83
g1
S'helper for pickle'
p84
sg3
I01
sg9
I2
sg10
g38
sa(dp85
g3
I01
sg9
I5
sg10
g40
sa(dp86
g3
I01
sg9
I5
sg10
g42
sa(dp87
g1
S'__sizeof__() -> int\nsize of object in memory, in bytes'
p88
sg3
I01
sg9
I2
sg10
g47
sa(dp89
g3
I01
sg9
I5
sg10
g49
sa(dp90
g1
S'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
p91
sg3
I01
sg9
I2
sg10
g52
sa(dp92
g3
I01
sg9
I5
sg10
S'_files'
p93
sa(dp94
g3
I01
sg9
I5
sg10
S'archive'
p95
sa(dp96
g1
S"find_module(fullname, path=None) -> self or None.\n\nSearch for a module specified by 'fullname'. 'fullname' must be the\nfully qualified (dotted) module name. It returns the zipimporter\ninstance itself if the module was found, or None if it wasn't.\nThe optional 'path' argument is ignored -- it's there for compatibility\nwith the importer protocol."
p97
sg3
I01
sg9
I2
sg10
S'find_module'
p98
sa(dp99
g1
S"get_code(fullname) -> code object.\n\nReturn the code object for the specified module. Raise ZipImportError\nif the module couldn't be found."
p100
sg3
I01
sg9
I2
sg10
S'get_code'
p101
sa(dp102
g1
S"get_data(pathname) -> string with file data.\n\nReturn the data associated with 'pathname'. Raise IOError if\nthe file wasn't found."
p103
sg3
I01
sg9
I2
sg10
S'get_data'
p104
sa(dp105
g1
S'get_filename(fullname) -> filename string.\n\nReturn the filename for the specified module.'
p106
sg3
I01
sg9
I2
sg10
S'get_filename'
p107
sa(dp108
g1
S"get_source(fullname) -> source string.\n\nReturn the source code for the specified module. Raise ZipImportError\nif the module couldn't be found, return None if the archive does\ncontain the module, but has no source for it."
p109
sg3
I01
sg9
I2
sg10
S'get_source'
p110
sa(dp111
g1
S"is_package(fullname) -> bool.\n\nReturn True if the module specified by fullname is a package.\nRaise ZipImportError if the module couldn't be found."
p112
sg3
I01
sg9
I2
sg10
S'is_package'
p113
sa(dp114
g1
S"load_module(fullname) -> module.\n\nLoad the module specified by 'fullname'. 'fullname' must be the\nfully qualified (dotted) module name. It returns the imported\nmodule, or raises ZipImportError if it wasn't found."
p115
sg3
I01
sg9
I2
sg10
S'load_module'
p116
sa(dp117
g3
I01
sg9
I5
sg10
S'prefix'
p118
sasg9
I3
sg10
S'zipimporter'
p119
sasg10
S'zipimport'
p120
s.